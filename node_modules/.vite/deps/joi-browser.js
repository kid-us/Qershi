import {
  __commonJS
} from "./chunk-5WWUZCGV.js";

// node_modules/joi-browser/dist/joi-browser.js
var require_joi_browser = __commonJS({
  "node_modules/joi-browser/dist/joi-browser.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("Joi", [], factory);
      else if (typeof exports === "object")
        exports["Joi"] = factory();
      else
        root["Joi"] = factory();
    })(exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.i = function(value) {
            return value;
          };
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 32);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            (function(Buffer, process) {
              var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                return typeof obj;
              } : function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              };
              var Assert = __webpack_require__(17);
              var Crypto = __webpack_require__(15);
              var Path = __webpack_require__(37);
              var Util = __webpack_require__(16);
              var Escape = __webpack_require__(18);
              var internals = {};
              exports2.clone = function(obj, seen) {
                if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== "object" || obj === null) {
                  return obj;
                }
                seen = seen || /* @__PURE__ */ new Map();
                var lookup = seen.get(obj);
                if (lookup) {
                  return lookup;
                }
                var newObj = void 0;
                var cloneDeep = false;
                if (!Array.isArray(obj)) {
                  if (Buffer.isBuffer(obj)) {
                    newObj = Buffer.from(obj);
                  } else if (obj instanceof Date) {
                    newObj = new Date(obj.getTime());
                  } else if (obj instanceof RegExp) {
                    newObj = new RegExp(obj);
                  } else {
                    var proto = Object.getPrototypeOf(obj);
                    if (proto && proto.isImmutable) {
                      newObj = obj;
                    } else {
                      newObj = Object.create(proto);
                      cloneDeep = true;
                    }
                  }
                } else {
                  newObj = [];
                  cloneDeep = true;
                }
                seen.set(obj, newObj);
                if (cloneDeep) {
                  var keys = Object.getOwnPropertyNames(obj);
                  for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    var descriptor = Object.getOwnPropertyDescriptor(obj, key);
                    if (descriptor && (descriptor.get || descriptor.set)) {
                      Object.defineProperty(newObj, key, descriptor);
                    } else {
                      newObj[key] = exports2.clone(obj[key], seen);
                    }
                  }
                }
                return newObj;
              };
              exports2.merge = function(target, source, isNullOverride, isMergeArrays) {
                exports2.assert(target && (typeof target === "undefined" ? "undefined" : _typeof(target)) === "object", "Invalid target value: must be an object");
                exports2.assert(source === null || source === void 0 || (typeof source === "undefined" ? "undefined" : _typeof(source)) === "object", "Invalid source value: must be null, undefined, or an object");
                if (!source) {
                  return target;
                }
                if (Array.isArray(source)) {
                  exports2.assert(Array.isArray(target), "Cannot merge array onto an object");
                  if (isMergeArrays === false) {
                    target.length = 0;
                  }
                  for (var i = 0; i < source.length; ++i) {
                    target.push(exports2.clone(source[i]));
                  }
                  return target;
                }
                var keys = Object.keys(source);
                for (var _i = 0; _i < keys.length; ++_i) {
                  var key = keys[_i];
                  if (key === "__proto__") {
                    continue;
                  }
                  var value = source[key];
                  if (value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object") {
                    if (!target[key] || _typeof(target[key]) !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer.isBuffer(value) || value instanceof RegExp) {
                      target[key] = exports2.clone(value);
                    } else {
                      exports2.merge(target[key], value, isNullOverride, isMergeArrays);
                    }
                  } else {
                    if (value !== null && value !== void 0) {
                      target[key] = value;
                    } else if (isNullOverride !== false) {
                      target[key] = value;
                    }
                  }
                }
                return target;
              };
              exports2.applyToDefaults = function(defaults, options, isNullOverride) {
                exports2.assert(defaults && (typeof defaults === "undefined" ? "undefined" : _typeof(defaults)) === "object", "Invalid defaults value: must be an object");
                exports2.assert(!options || options === true || (typeof options === "undefined" ? "undefined" : _typeof(options)) === "object", "Invalid options value: must be true, falsy or an object");
                if (!options) {
                  return null;
                }
                var copy = exports2.clone(defaults);
                if (options === true) {
                  return copy;
                }
                return exports2.merge(copy, options, isNullOverride === true, false);
              };
              exports2.cloneWithShallow = function(source, keys) {
                if (!source || (typeof source === "undefined" ? "undefined" : _typeof(source)) !== "object") {
                  return source;
                }
                var storage = internals.store(source, keys);
                var copy = exports2.clone(source);
                internals.restore(copy, source, storage);
                return copy;
              };
              internals.store = function(source, keys) {
                var storage = {};
                for (var i = 0; i < keys.length; ++i) {
                  var key = keys[i];
                  var value = exports2.reach(source, key);
                  if (value !== void 0) {
                    storage[key] = value;
                    internals.reachSet(source, key, void 0);
                  }
                }
                return storage;
              };
              internals.restore = function(copy, source, storage) {
                var keys = Object.keys(storage);
                for (var i = 0; i < keys.length; ++i) {
                  var key = keys[i];
                  internals.reachSet(copy, key, storage[key]);
                  internals.reachSet(source, key, storage[key]);
                }
              };
              internals.reachSet = function(obj, key, value) {
                var path = key.split(".");
                var ref = obj;
                for (var i = 0; i < path.length; ++i) {
                  var segment = path[i];
                  if (i + 1 === path.length) {
                    ref[segment] = value;
                  }
                  ref = ref[segment];
                }
              };
              exports2.applyToDefaultsWithShallow = function(defaults, options, keys) {
                exports2.assert(defaults && (typeof defaults === "undefined" ? "undefined" : _typeof(defaults)) === "object", "Invalid defaults value: must be an object");
                exports2.assert(!options || options === true || (typeof options === "undefined" ? "undefined" : _typeof(options)) === "object", "Invalid options value: must be true, falsy or an object");
                exports2.assert(keys && Array.isArray(keys), "Invalid keys");
                if (!options) {
                  return null;
                }
                var copy = exports2.cloneWithShallow(defaults, keys);
                if (options === true) {
                  return copy;
                }
                var storage = internals.store(options, keys);
                exports2.merge(copy, options, false, false);
                internals.restore(copy, options, storage);
                return copy;
              };
              exports2.deepEqual = function(obj, ref, options, seen) {
                options = options || { prototype: true };
                var type = typeof obj === "undefined" ? "undefined" : _typeof(obj);
                if (type !== (typeof ref === "undefined" ? "undefined" : _typeof(ref))) {
                  return false;
                }
                if (type !== "object" || obj === null || ref === null) {
                  if (obj === ref) {
                    return obj !== 0 || 1 / obj === 1 / ref;
                  }
                  return obj !== obj && ref !== ref;
                }
                seen = seen || [];
                if (seen.indexOf(obj) !== -1) {
                  return true;
                }
                seen.push(obj);
                if (Array.isArray(obj)) {
                  if (!Array.isArray(ref)) {
                    return false;
                  }
                  if (!options.part && obj.length !== ref.length) {
                    return false;
                  }
                  for (var i = 0; i < obj.length; ++i) {
                    if (options.part) {
                      var found = false;
                      for (var j = 0; j < ref.length; ++j) {
                        if (exports2.deepEqual(obj[i], ref[j], options)) {
                          found = true;
                          break;
                        }
                      }
                      return found;
                    }
                    if (!exports2.deepEqual(obj[i], ref[i], options)) {
                      return false;
                    }
                  }
                  return true;
                }
                if (Buffer.isBuffer(obj)) {
                  if (!Buffer.isBuffer(ref)) {
                    return false;
                  }
                  if (obj.length !== ref.length) {
                    return false;
                  }
                  for (var _i2 = 0; _i2 < obj.length; ++_i2) {
                    if (obj[_i2] !== ref[_i2]) {
                      return false;
                    }
                  }
                  return true;
                }
                if (obj instanceof Date) {
                  return ref instanceof Date && obj.getTime() === ref.getTime();
                }
                if (obj instanceof RegExp) {
                  return ref instanceof RegExp && obj.toString() === ref.toString();
                }
                if (options.prototype) {
                  if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
                    return false;
                  }
                }
                var keys = Object.getOwnPropertyNames(obj);
                if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {
                  return false;
                }
                for (var _i3 = 0; _i3 < keys.length; ++_i3) {
                  var key = keys[_i3];
                  var descriptor = Object.getOwnPropertyDescriptor(obj, key);
                  if (descriptor.get) {
                    if (!exports2.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {
                      return false;
                    }
                  } else if (!exports2.deepEqual(obj[key], ref[key], options, seen)) {
                    return false;
                  }
                }
                return true;
              };
              exports2.unique = function(array, key) {
                var result = void 0;
                if (key) {
                  result = [];
                  var index = /* @__PURE__ */ new Set();
                  array.forEach(function(item) {
                    var identifier = item[key];
                    if (!index.has(identifier)) {
                      index.add(identifier);
                      result.push(item);
                    }
                  });
                } else {
                  result = Array.from(new Set(array));
                }
                return result;
              };
              exports2.mapToObject = function(array, key) {
                if (!array) {
                  return null;
                }
                var obj = {};
                for (var i = 0; i < array.length; ++i) {
                  if (key) {
                    if (array[i][key]) {
                      obj[array[i][key]] = true;
                    }
                  } else {
                    obj[array[i]] = true;
                  }
                }
                return obj;
              };
              exports2.intersect = function(array1, array2, justFirst) {
                if (!array1 || !array2) {
                  return [];
                }
                var common = [];
                var hash = Array.isArray(array1) ? exports2.mapToObject(array1) : array1;
                var found = {};
                for (var i = 0; i < array2.length; ++i) {
                  if (hash[array2[i]] && !found[array2[i]]) {
                    if (justFirst) {
                      return array2[i];
                    }
                    common.push(array2[i]);
                    found[array2[i]] = true;
                  }
                }
                return justFirst ? null : common;
              };
              exports2.contain = function(ref, values, options) {
                var valuePairs = null;
                if ((typeof ref === "undefined" ? "undefined" : _typeof(ref)) === "object" && (typeof values === "undefined" ? "undefined" : _typeof(values)) === "object" && !Array.isArray(ref) && !Array.isArray(values)) {
                  valuePairs = values;
                  values = Object.keys(values);
                } else {
                  values = [].concat(values);
                }
                options = options || {};
                exports2.assert(typeof ref === "string" || (typeof ref === "undefined" ? "undefined" : _typeof(ref)) === "object", "Reference must be string or an object");
                exports2.assert(values.length, "Values array cannot be empty");
                var compare = void 0;
                var compareFlags = void 0;
                if (options.deep) {
                  compare = exports2.deepEqual;
                  var hasOnly = options.hasOwnProperty("only");
                  var hasPart = options.hasOwnProperty("part");
                  compareFlags = {
                    prototype: hasOnly ? options.only : hasPart ? !options.part : false,
                    part: hasOnly ? !options.only : hasPart ? options.part : true
                  };
                } else {
                  compare = function compare2(a, b) {
                    return a === b;
                  };
                }
                var misses = false;
                var matches = new Array(values.length);
                for (var i = 0; i < matches.length; ++i) {
                  matches[i] = 0;
                }
                if (typeof ref === "string") {
                  var pattern = "(";
                  for (var _i4 = 0; _i4 < values.length; ++_i4) {
                    var value = values[_i4];
                    exports2.assert(typeof value === "string", "Cannot compare string reference to non-string value");
                    pattern += (_i4 ? "|" : "") + exports2.escapeRegex(value);
                  }
                  var regex = new RegExp(pattern + ")", "g");
                  var leftovers = ref.replace(regex, function($0, $1) {
                    var index = values.indexOf($1);
                    ++matches[index];
                    return "";
                  });
                  misses = !!leftovers;
                } else if (Array.isArray(ref)) {
                  for (var _i5 = 0; _i5 < ref.length; ++_i5) {
                    var matched = false;
                    for (var j = 0; j < values.length && matched === false; ++j) {
                      matched = compare(values[j], ref[_i5], compareFlags) && j;
                    }
                    if (matched !== false) {
                      ++matches[matched];
                    } else {
                      misses = true;
                    }
                  }
                } else {
                  var keys = Object.getOwnPropertyNames(ref);
                  for (var _i6 = 0; _i6 < keys.length; ++_i6) {
                    var key = keys[_i6];
                    var pos = values.indexOf(key);
                    if (pos !== -1) {
                      if (valuePairs && !compare(valuePairs[key], ref[key], compareFlags)) {
                        return false;
                      }
                      ++matches[pos];
                    } else {
                      misses = true;
                    }
                  }
                }
                var result = false;
                for (var _i7 = 0; _i7 < matches.length; ++_i7) {
                  result = result || !!matches[_i7];
                  if (options.once && matches[_i7] > 1 || !options.part && !matches[_i7]) {
                    return false;
                  }
                }
                if (options.only && misses) {
                  return false;
                }
                return result;
              };
              exports2.flatten = function(array, target) {
                var result = target || [];
                for (var i = 0; i < array.length; ++i) {
                  if (Array.isArray(array[i])) {
                    exports2.flatten(array[i], result);
                  } else {
                    result.push(array[i]);
                  }
                }
                return result;
              };
              exports2.reach = function(obj, chain, options) {
                if (chain === false || chain === null || typeof chain === "undefined") {
                  return obj;
                }
                options = options || {};
                if (typeof options === "string") {
                  options = { separator: options };
                }
                var path = chain.split(options.separator || ".");
                var ref = obj;
                for (var i = 0; i < path.length; ++i) {
                  var key = path[i];
                  if (key[0] === "-" && Array.isArray(ref)) {
                    key = key.slice(1, key.length);
                    key = ref.length - key;
                  }
                  if (!ref || !(((typeof ref === "undefined" ? "undefined" : _typeof(ref)) === "object" || typeof ref === "function") && key in ref) || (typeof ref === "undefined" ? "undefined" : _typeof(ref)) !== "object" && options.functions === false) {
                    exports2.assert(!options.strict || i + 1 === path.length, "Missing segment", key, "in reach path ", chain);
                    exports2.assert((typeof ref === "undefined" ? "undefined" : _typeof(ref)) === "object" || options.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
                    ref = options.default;
                    break;
                  }
                  ref = ref[key];
                }
                return ref;
              };
              exports2.reachTemplate = function(obj, template, options) {
                return template.replace(/{([^}]+)}/g, function($0, chain) {
                  var value = exports2.reach(obj, chain, options);
                  return value === void 0 || value === null ? "" : value;
                });
              };
              exports2.formatStack = function(stack) {
                var trace = [];
                for (var i = 0; i < stack.length; ++i) {
                  var item = stack[i];
                  trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
                }
                return trace;
              };
              exports2.formatTrace = function(trace) {
                var display = [];
                for (var i = 0; i < trace.length; ++i) {
                  var row = trace[i];
                  display.push((row[4] ? "new " : "") + row[3] + " (" + row[0] + ":" + row[1] + ":" + row[2] + ")");
                }
                return display;
              };
              exports2.callStack = function(slice) {
                var v8 = Error.prepareStackTrace;
                Error.prepareStackTrace = function(_, stack2) {
                  return stack2;
                };
                var capture = {};
                Error.captureStackTrace(capture, this);
                var stack = capture.stack;
                Error.prepareStackTrace = v8;
                var trace = exports2.formatStack(stack);
                return trace.slice(1 + slice);
              };
              exports2.displayStack = function(slice) {
                var trace = exports2.callStack(slice === void 0 ? 1 : slice + 1);
                return exports2.formatTrace(trace);
              };
              exports2.abortThrow = false;
              exports2.abort = function(message, hideStack) {
                if (process.env.NODE_ENV === "test" || exports2.abortThrow === true) {
                  throw new Error(message || "Unknown error");
                }
                var stack = "";
                if (!hideStack) {
                  stack = exports2.displayStack(1).join("\n	");
                }
                console.log("ABORT: " + message + "\n	" + stack);
                process.exit(1);
              };
              exports2.assert = function(condition) {
                if (condition) {
                  return;
                }
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                if (args.length === 1 && args[0] instanceof Error) {
                  throw args[0];
                }
                var msgs = args.filter(function(arg) {
                  return arg !== "";
                }).map(function(arg) {
                  return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : exports2.stringify(arg);
                });
                throw new Assert.AssertionError({
                  message: msgs.join(" ") || "Unknown error",
                  actual: false,
                  expected: true,
                  operator: "==",
                  stackStartFunction: exports2.assert
                });
              };
              exports2.Bench = function() {
                this.ts = 0;
                this.reset();
              };
              exports2.Bench.prototype.reset = function() {
                this.ts = exports2.Bench.now();
              };
              exports2.Bench.prototype.elapsed = function() {
                return exports2.Bench.now() - this.ts;
              };
              exports2.Bench.now = function() {
                var ts = process.hrtime();
                return ts[0] * 1e3 + ts[1] / 1e6;
              };
              exports2.escapeRegex = function(string) {
                return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
              };
              exports2.base64urlEncode = function(value, encoding) {
                exports2.assert(typeof value === "string" || Buffer.isBuffer(value), "value must be string or buffer");
                var buf = Buffer.isBuffer(value) ? value : Buffer.from(value, encoding || "binary");
                return buf.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
              };
              exports2.base64urlDecode = function(value, encoding) {
                if (typeof value !== "string") {
                  throw new Error("Value not a string");
                }
                if (!/^[\w\-]*$/.test(value)) {
                  throw new Error("Invalid character");
                }
                var buf = Buffer.from(value, "base64");
                return encoding === "buffer" ? buf : buf.toString(encoding || "binary");
              };
              exports2.escapeHeaderAttribute = function(attribute) {
                exports2.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), "Bad attribute value (" + attribute + ")");
                return attribute.replace(/\\/g, "\\\\").replace(/\"/g, '\\"');
              };
              exports2.escapeHtml = function(string) {
                return Escape.escapeHtml(string);
              };
              exports2.escapeJavaScript = function(string) {
                return Escape.escapeJavaScript(string);
              };
              exports2.escapeJson = function(string) {
                return Escape.escapeJson(string);
              };
              exports2.once = function(method) {
                if (method._hoekOnce) {
                  return method;
                }
                var once = false;
                var wrapped = function wrapped2() {
                  if (!once) {
                    once = true;
                    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                      args[_key2] = arguments[_key2];
                    }
                    method.apply(null, args);
                  }
                };
                wrapped._hoekOnce = true;
                return wrapped;
              };
              exports2.isInteger = Number.isSafeInteger;
              exports2.ignore = function() {
              };
              exports2.inherits = Util.inherits;
              exports2.format = Util.format;
              exports2.transform = function(source, transform, options) {
                exports2.assert(source === null || source === void 0 || (typeof source === "undefined" ? "undefined" : _typeof(source)) === "object" || Array.isArray(source), "Invalid source object: must be null, undefined, an object, or an array");
                var separator = (typeof options === "undefined" ? "undefined" : _typeof(options)) === "object" && options !== null ? options.separator || "." : ".";
                if (Array.isArray(source)) {
                  var results = [];
                  for (var i = 0; i < source.length; ++i) {
                    results.push(exports2.transform(source[i], transform, options));
                  }
                  return results;
                }
                var result = {};
                var keys = Object.keys(transform);
                for (var _i8 = 0; _i8 < keys.length; ++_i8) {
                  var key = keys[_i8];
                  var path = key.split(separator);
                  var sourcePath = transform[key];
                  exports2.assert(typeof sourcePath === "string", 'All mappings must be "." delineated strings');
                  var segment = void 0;
                  var res = result;
                  while (path.length > 1) {
                    segment = path.shift();
                    if (!res[segment]) {
                      res[segment] = {};
                    }
                    res = res[segment];
                  }
                  segment = path.shift();
                  res[segment] = exports2.reach(source, sourcePath, options);
                }
                return result;
              };
              exports2.uniqueFilename = function(path, extension) {
                if (extension) {
                  extension = extension[0] !== "." ? "." + extension : extension;
                } else {
                  extension = "";
                }
                path = Path.resolve(path);
                var name = [Date.now(), process.pid, Crypto.randomBytes(8).toString("hex")].join("-") + extension;
                return Path.join(path, name);
              };
              exports2.stringify = function() {
                try {
                  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                    args[_key3] = arguments[_key3];
                  }
                  return JSON.stringify.apply(null, args);
                } catch (err) {
                  return "[Cannot display object: " + err.message + "]";
                }
              };
              exports2.shallow = function(source) {
                var target = {};
                var keys = Object.keys(source);
                for (var i = 0; i < keys.length; ++i) {
                  var key = keys[i];
                  target[key] = source[key];
                }
                return target;
              };
              exports2.wait = function(timeout) {
                return new Promise(function(resolve) {
                  return setTimeout(resolve, timeout);
                });
              };
              exports2.block = function() {
                return new Promise(exports2.ignore);
              };
            }).call(exports2, __webpack_require__(3).Buffer, __webpack_require__(7));
          },
          /* 1 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var Hoek = __webpack_require__(0);
            var internals = {};
            exports2.create = function(key, options) {
              Hoek.assert(typeof key === "string", "Invalid reference key:", key);
              var settings = Hoek.clone(options);
              var ref = function ref2(value, validationOptions) {
                return Hoek.reach(ref2.isContext ? validationOptions.context : value, ref2.key, settings);
              };
              ref.isContext = key[0] === (settings && settings.contextPrefix || "$");
              ref.key = ref.isContext ? key.slice(1) : key;
              ref.path = ref.key.split(settings && settings.separator || ".");
              ref.depth = ref.path.length;
              ref.root = ref.path[0];
              ref.isJoi = true;
              ref.toString = function() {
                return (ref.isContext ? "context:" : "ref:") + ref.key;
              };
              return ref;
            };
            exports2.isRef = function(ref) {
              return typeof ref === "function" && ref.isJoi;
            };
            exports2.push = function(array, ref) {
              if (exports2.isRef(ref) && !ref.isContext) {
                array.push(ref.root);
              }
            };
          },
          /* 2 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Hoek = __webpack_require__(0);
            var Settings = __webpack_require__(11);
            var Ref = __webpack_require__(1);
            var Errors = __webpack_require__(6);
            var Alternatives = null;
            var Cast = null;
            var internals = {
              Set: __webpack_require__(9)
            };
            internals.defaults = {
              abortEarly: true,
              convert: true,
              allowUnknown: false,
              skipFunctions: false,
              stripUnknown: false,
              language: {},
              presence: "optional",
              strip: false,
              noDefaults: false,
              escapeHtml: false
              // context: null
            };
            module2.exports = internals.Any = function() {
              function _class() {
                _classCallCheck(this, _class);
                Cast = Cast || __webpack_require__(4);
                this.isJoi = true;
                this._type = "any";
                this._settings = null;
                this._valids = new internals.Set();
                this._invalids = new internals.Set();
                this._tests = [];
                this._refs = [];
                this._flags = {
                  /*
                   presence: 'optional',                   // optional, required, forbidden, ignore
                   allowOnly: false,
                   allowUnknown: undefined,
                   default: undefined,
                   forbidden: false,
                   encoding: undefined,
                   insensitive: false,
                   trim: false,
                   normalize: undefined,                   // NFC, NFD, NFKC, NFKD
                   case: undefined,                        // upper, lower
                   empty: undefined,
                   func: false,
                   raw: false
                   */
                };
                this._description = null;
                this._unit = null;
                this._notes = [];
                this._tags = [];
                this._examples = [];
                this._meta = [];
                this._inner = {};
              }
              _class.prototype._init = function _init() {
                return this;
              };
              _class.prototype.createError = function createError(type, context, state, options) {
                var flags = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this._flags;
                return Errors.create(type, context, state, options, flags);
              };
              _class.prototype.createOverrideError = function createOverrideError(type, context, state, options, message, template) {
                return Errors.create(type, context, state, options, this._flags, message, template);
              };
              _class.prototype.checkOptions = function checkOptions(options) {
                var Schemas = __webpack_require__(21);
                var result = Schemas.options.validate(options);
                if (result.error) {
                  throw new Error(result.error.details[0].message);
                }
              };
              _class.prototype.clone = function clone() {
                var obj = Object.create(Object.getPrototypeOf(this));
                obj.isJoi = true;
                obj._currentJoi = this._currentJoi;
                obj._type = this._type;
                obj._settings = this._settings;
                obj._baseType = this._baseType;
                obj._valids = this._valids.slice();
                obj._invalids = this._invalids.slice();
                obj._tests = this._tests.slice();
                obj._refs = this._refs.slice();
                obj._flags = Hoek.clone(this._flags);
                obj._description = this._description;
                obj._unit = this._unit;
                obj._notes = this._notes.slice();
                obj._tags = this._tags.slice();
                obj._examples = this._examples.slice();
                obj._meta = this._meta.slice();
                obj._inner = {};
                var inners = Object.keys(this._inner);
                for (var i = 0; i < inners.length; ++i) {
                  var key = inners[i];
                  obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;
                }
                return obj;
              };
              _class.prototype.concat = function concat(schema) {
                Hoek.assert(schema instanceof internals.Any, "Invalid schema object");
                Hoek.assert(this._type === "any" || schema._type === "any" || schema._type === this._type, "Cannot merge type", this._type, "with another type:", schema._type);
                var obj = this.clone();
                if (this._type === "any" && schema._type !== "any") {
                  var tmpObj = schema.clone();
                  var keysToRestore = ["_settings", "_valids", "_invalids", "_tests", "_refs", "_flags", "_description", "_unit", "_notes", "_tags", "_examples", "_meta", "_inner"];
                  for (var i = 0; i < keysToRestore.length; ++i) {
                    tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];
                  }
                  obj = tmpObj;
                }
                obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;
                obj._valids.merge(schema._valids, schema._invalids);
                obj._invalids.merge(schema._invalids, schema._valids);
                obj._tests = obj._tests.concat(schema._tests);
                obj._refs = obj._refs.concat(schema._refs);
                Hoek.merge(obj._flags, schema._flags);
                obj._description = schema._description || obj._description;
                obj._unit = schema._unit || obj._unit;
                obj._notes = obj._notes.concat(schema._notes);
                obj._tags = obj._tags.concat(schema._tags);
                obj._examples = obj._examples.concat(schema._examples);
                obj._meta = obj._meta.concat(schema._meta);
                var inners = Object.keys(schema._inner);
                var isObject = obj._type === "object";
                for (var _i = 0; _i < inners.length; ++_i) {
                  var key = inners[_i];
                  var source = schema._inner[key];
                  if (source) {
                    var target = obj._inner[key];
                    if (target) {
                      if (isObject && key === "children") {
                        var keys = {};
                        for (var j = 0; j < target.length; ++j) {
                          keys[target[j].key] = j;
                        }
                        for (var _j = 0; _j < source.length; ++_j) {
                          var sourceKey = source[_j].key;
                          if (keys[sourceKey] >= 0) {
                            target[keys[sourceKey]] = {
                              key: sourceKey,
                              schema: target[keys[sourceKey]].schema.concat(source[_j].schema)
                            };
                          } else {
                            target.push(source[_j]);
                          }
                        }
                      } else {
                        obj._inner[key] = obj._inner[key].concat(source);
                      }
                    } else {
                      obj._inner[key] = source.slice();
                    }
                  }
                }
                return obj;
              };
              _class.prototype._test = function _test(name, arg, func, options) {
                var obj = this.clone();
                obj._tests.push({ func, name, arg, options });
                return obj;
              };
              _class.prototype.options = function options(_options) {
                Hoek.assert(!_options.context, "Cannot override context");
                this.checkOptions(_options);
                var obj = this.clone();
                obj._settings = Settings.concat(obj._settings, _options);
                return obj;
              };
              _class.prototype.strict = function strict(isStrict) {
                var obj = this.clone();
                var convert = isStrict === void 0 ? false : !isStrict;
                obj._settings = Settings.concat(obj._settings, { convert });
                return obj;
              };
              _class.prototype.raw = function raw(isRaw) {
                var value = isRaw === void 0 ? true : isRaw;
                if (this._flags.raw === value) {
                  return this;
                }
                var obj = this.clone();
                obj._flags.raw = value;
                return obj;
              };
              _class.prototype.error = function error(err) {
                Hoek.assert(err && (err instanceof Error || typeof err === "function"), "Must provide a valid Error object or a function");
                var obj = this.clone();
                obj._flags.error = err;
                return obj;
              };
              _class.prototype.allow = function allow() {
                for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
                  values[_key] = arguments[_key];
                }
                var obj = this.clone();
                values = Hoek.flatten(values);
                for (var i = 0; i < values.length; ++i) {
                  var value = values[i];
                  Hoek.assert(value !== void 0, "Cannot call allow/valid/invalid with undefined");
                  obj._invalids.remove(value);
                  obj._valids.add(value, obj._refs);
                }
                return obj;
              };
              _class.prototype.valid = function valid() {
                var obj = this.allow.apply(this, arguments);
                obj._flags.allowOnly = true;
                return obj;
              };
              _class.prototype.invalid = function invalid() {
                for (var _len2 = arguments.length, values = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  values[_key2] = arguments[_key2];
                }
                var obj = this.clone();
                values = Hoek.flatten(values);
                for (var i = 0; i < values.length; ++i) {
                  var value = values[i];
                  Hoek.assert(value !== void 0, "Cannot call allow/valid/invalid with undefined");
                  obj._valids.remove(value);
                  obj._invalids.add(value, obj._refs);
                }
                return obj;
              };
              _class.prototype.required = function required() {
                if (this._flags.presence === "required") {
                  return this;
                }
                var obj = this.clone();
                obj._flags.presence = "required";
                return obj;
              };
              _class.prototype.optional = function optional() {
                if (this._flags.presence === "optional") {
                  return this;
                }
                var obj = this.clone();
                obj._flags.presence = "optional";
                return obj;
              };
              _class.prototype.forbidden = function forbidden() {
                if (this._flags.presence === "forbidden") {
                  return this;
                }
                var obj = this.clone();
                obj._flags.presence = "forbidden";
                return obj;
              };
              _class.prototype.strip = function strip() {
                if (this._flags.strip) {
                  return this;
                }
                var obj = this.clone();
                obj._flags.strip = true;
                return obj;
              };
              _class.prototype.applyFunctionToChildren = function applyFunctionToChildren(children, fn, args, root) {
                children = [].concat(children);
                if (children.length !== 1 || children[0] !== "") {
                  root = root ? root + "." : "";
                  var extraChildren = (children[0] === "" ? children.slice(1) : children).map(function(child) {
                    return root + child;
                  });
                  throw new Error("unknown key(s) " + extraChildren.join(", "));
                }
                return this[fn].apply(this, args);
              };
              _class.prototype.default = function _default(value, description) {
                if (typeof value === "function" && !Ref.isRef(value)) {
                  if (!value.description && description) {
                    value.description = description;
                  }
                  if (!this._flags.func) {
                    Hoek.assert(typeof value.description === "string" && value.description.length > 0, "description must be provided when default value is a function");
                  }
                }
                var obj = this.clone();
                obj._flags.default = value;
                Ref.push(obj._refs, value);
                return obj;
              };
              _class.prototype.empty = function empty(schema) {
                var obj = this.clone();
                if (schema === void 0) {
                  delete obj._flags.empty;
                } else {
                  obj._flags.empty = Cast.schema(this._currentJoi, schema);
                }
                return obj;
              };
              _class.prototype.when = function when(condition, options) {
                Hoek.assert(options && (typeof options === "undefined" ? "undefined" : _typeof(options)) === "object", "Invalid options");
                Hoek.assert(options.then !== void 0 || options.otherwise !== void 0, 'options must have at least one of "then" or "otherwise"');
                var then = options.hasOwnProperty("then") ? this.concat(Cast.schema(this._currentJoi, options.then)) : void 0;
                var otherwise = options.hasOwnProperty("otherwise") ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : void 0;
                Alternatives = Alternatives || __webpack_require__(10);
                var alternativeOptions = { then, otherwise };
                if (Object.prototype.hasOwnProperty.call(options, "is")) {
                  alternativeOptions.is = options.is;
                }
                var obj = Alternatives.when(condition, alternativeOptions);
                obj._flags.presence = "ignore";
                obj._baseType = this;
                return obj;
              };
              _class.prototype.description = function description(desc) {
                Hoek.assert(desc && typeof desc === "string", "Description must be a non-empty string");
                var obj = this.clone();
                obj._description = desc;
                return obj;
              };
              _class.prototype.notes = function notes(_notes) {
                Hoek.assert(_notes && (typeof _notes === "string" || Array.isArray(_notes)), "Notes must be a non-empty string or array");
                var obj = this.clone();
                obj._notes = obj._notes.concat(_notes);
                return obj;
              };
              _class.prototype.tags = function tags(_tags) {
                Hoek.assert(_tags && (typeof _tags === "string" || Array.isArray(_tags)), "Tags must be a non-empty string or array");
                var obj = this.clone();
                obj._tags = obj._tags.concat(_tags);
                return obj;
              };
              _class.prototype.meta = function meta(_meta) {
                Hoek.assert(_meta !== void 0, "Meta cannot be undefined");
                var obj = this.clone();
                obj._meta = obj._meta.concat(_meta);
                return obj;
              };
              _class.prototype.example = function example() {
                Hoek.assert(arguments.length === 1, "Missing example");
                var value = arguments.length <= 0 ? void 0 : arguments[0];
                var obj = this.clone();
                obj._examples.push(value);
                return obj;
              };
              _class.prototype.unit = function unit(name) {
                Hoek.assert(name && typeof name === "string", "Unit name must be a non-empty string");
                var obj = this.clone();
                obj._unit = name;
                return obj;
              };
              _class.prototype._prepareEmptyValue = function _prepareEmptyValue(value) {
                if (typeof value === "string" && this._flags.trim) {
                  return value.trim();
                }
                return value;
              };
              _class.prototype._validate = function _validate(value, state, options, reference) {
                var _this = this;
                var originalValue = value;
                state = state || { key: "", path: [], parent: null, reference };
                if (this._settings) {
                  options = Settings.concat(options, this._settings);
                }
                var errors = [];
                var finish = function finish2() {
                  var finalValue = void 0;
                  if (value !== void 0) {
                    finalValue = _this._flags.raw ? originalValue : value;
                  } else if (options.noDefaults) {
                    finalValue = value;
                  } else if (Ref.isRef(_this._flags.default)) {
                    finalValue = _this._flags.default(state.parent, options);
                  } else if (typeof _this._flags.default === "function" && !(_this._flags.func && !_this._flags.default.description)) {
                    var args = void 0;
                    if (state.parent !== null && _this._flags.default.length > 0) {
                      args = [Hoek.clone(state.parent), options];
                    }
                    var defaultValue = internals._try(_this._flags.default, args);
                    finalValue = defaultValue.value;
                    if (defaultValue.error) {
                      errors.push(_this.createError("any.default", { error: defaultValue.error }, state, options));
                    }
                  } else {
                    finalValue = Hoek.clone(_this._flags.default);
                  }
                  if (errors.length && typeof _this._flags.error === "function") {
                    var change = _this._flags.error.call(_this, errors);
                    if (typeof change === "string") {
                      errors = [_this.createOverrideError("override", { reason: errors }, state, options, change)];
                    } else {
                      errors = [].concat(change).map(function(err) {
                        return err instanceof Error ? err : _this.createOverrideError(err.type || "override", err.context, state, options, err.message, err.template);
                      });
                    }
                  }
                  return {
                    value: _this._flags.strip ? void 0 : finalValue,
                    finalValue,
                    errors: errors.length ? errors : null
                  };
                };
                if (this._coerce) {
                  var coerced = this._coerce.call(this, value, state, options);
                  if (coerced.errors) {
                    value = coerced.value;
                    errors = errors.concat(coerced.errors);
                    return finish();
                  }
                  value = coerced.value;
                }
                if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {
                  value = void 0;
                }
                var presence = this._flags.presence || options.presence;
                if (presence === "optional") {
                  if (value === void 0) {
                    var isDeepDefault = this._flags.hasOwnProperty("default") && this._flags.default === void 0;
                    if (isDeepDefault && this._type === "object") {
                      value = {};
                    } else {
                      return finish();
                    }
                  }
                } else if (presence === "required" && value === void 0) {
                  errors.push(this.createError("any.required", null, state, options));
                  return finish();
                } else if (presence === "forbidden") {
                  if (value === void 0) {
                    return finish();
                  }
                  errors.push(this.createError("any.unknown", null, state, options));
                  return finish();
                }
                if (this._valids.has(value, state, options, this._flags.insensitive)) {
                  return finish();
                }
                if (this._invalids.has(value, state, options, this._flags.insensitive)) {
                  errors.push(this.createError(value === "" ? "any.empty" : "any.invalid", { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));
                  if (options.abortEarly || value === void 0) {
                    return finish();
                  }
                }
                if (this._base) {
                  var base = this._base.call(this, value, state, options);
                  if (base.errors) {
                    value = base.value;
                    errors = errors.concat(base.errors);
                    return finish();
                  }
                  if (base.value !== value) {
                    value = base.value;
                    if (this._valids.has(value, state, options, this._flags.insensitive)) {
                      return finish();
                    }
                    if (this._invalids.has(value, state, options, this._flags.insensitive)) {
                      errors.push(this.createError(value === "" ? "any.empty" : "any.invalid", { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));
                      if (options.abortEarly) {
                        return finish();
                      }
                    }
                  }
                }
                if (this._flags.allowOnly) {
                  errors.push(this.createError("any.allowOnly", { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));
                  if (options.abortEarly) {
                    return finish();
                  }
                }
                for (var i = 0; i < this._tests.length; ++i) {
                  var test = this._tests[i];
                  var ret = test.func.call(this, value, state, options);
                  if (ret instanceof Errors.Err) {
                    errors.push(ret);
                    if (options.abortEarly) {
                      return finish();
                    }
                  } else {
                    value = ret;
                  }
                }
                return finish();
              };
              _class.prototype._validateWithOptions = function _validateWithOptions(value, options, callback) {
                if (options) {
                  this.checkOptions(options);
                }
                var settings = Settings.concat(internals.defaults, options);
                var result = this._validate(value, null, settings);
                var errors = Errors.process(result.errors, value);
                if (callback) {
                  return callback(errors, result.value);
                }
                return {
                  error: errors,
                  value: result.value,
                  then: function then(resolve, reject) {
                    if (errors) {
                      return Promise.reject(errors).catch(reject);
                    }
                    return Promise.resolve(result.value).then(resolve);
                  },
                  catch: function _catch(reject) {
                    if (errors) {
                      return Promise.reject(errors).catch(reject);
                    }
                    return Promise.resolve(result.value);
                  }
                };
              };
              _class.prototype.validate = function validate(value, options, callback) {
                if (typeof options === "function") {
                  return this._validateWithOptions(value, null, options);
                }
                return this._validateWithOptions(value, options, callback);
              };
              _class.prototype.describe = function describe() {
                var _this2 = this;
                var description = {
                  type: this._type
                };
                var flags = Object.keys(this._flags);
                if (flags.length) {
                  if (["empty", "default", "lazy", "label"].some(function(flag2) {
                    return _this2._flags.hasOwnProperty(flag2);
                  })) {
                    description.flags = {};
                    for (var i = 0; i < flags.length; ++i) {
                      var flag = flags[i];
                      if (flag === "empty") {
                        description.flags[flag] = this._flags[flag].describe();
                      } else if (flag === "default") {
                        if (Ref.isRef(this._flags[flag])) {
                          description.flags[flag] = this._flags[flag].toString();
                        } else if (typeof this._flags[flag] === "function") {
                          description.flags[flag] = {
                            description: this._flags[flag].description,
                            function: this._flags[flag]
                          };
                        } else {
                          description.flags[flag] = this._flags[flag];
                        }
                      } else if (flag === "lazy" || flag === "label") {
                      } else {
                        description.flags[flag] = this._flags[flag];
                      }
                    }
                  } else {
                    description.flags = this._flags;
                  }
                }
                if (this._settings) {
                  description.options = Hoek.clone(this._settings);
                }
                if (this._baseType) {
                  description.base = this._baseType.describe();
                }
                if (this._description) {
                  description.description = this._description;
                }
                if (this._notes.length) {
                  description.notes = this._notes;
                }
                if (this._tags.length) {
                  description.tags = this._tags;
                }
                if (this._meta.length) {
                  description.meta = this._meta;
                }
                if (this._examples.length) {
                  description.examples = this._examples;
                }
                if (this._unit) {
                  description.unit = this._unit;
                }
                var valids = this._valids.values();
                if (valids.length) {
                  description.valids = valids.map(function(v) {
                    return Ref.isRef(v) ? v.toString() : v;
                  });
                }
                var invalids = this._invalids.values();
                if (invalids.length) {
                  description.invalids = invalids.map(function(v) {
                    return Ref.isRef(v) ? v.toString() : v;
                  });
                }
                description.rules = [];
                for (var _i2 = 0; _i2 < this._tests.length; ++_i2) {
                  var validator = this._tests[_i2];
                  var item = { name: validator.name };
                  if (validator.arg !== void 0) {
                    item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;
                  }
                  var options = validator.options;
                  if (options) {
                    if (options.hasRef) {
                      item.arg = {};
                      var keys = Object.keys(validator.arg);
                      for (var j = 0; j < keys.length; ++j) {
                        var key = keys[j];
                        var value = validator.arg[key];
                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;
                      }
                    }
                    if (typeof options.description === "string") {
                      item.description = options.description;
                    } else if (typeof options.description === "function") {
                      item.description = options.description(item.arg);
                    }
                  }
                  description.rules.push(item);
                }
                if (!description.rules.length) {
                  delete description.rules;
                }
                var label = this._getLabel();
                if (label) {
                  description.label = label;
                }
                return description;
              };
              _class.prototype.label = function label(name) {
                Hoek.assert(name && typeof name === "string", "Label name must be a non-empty string");
                var obj = this.clone();
                obj._flags.label = name;
                return obj;
              };
              _class.prototype._getLabel = function _getLabel(def) {
                return this._flags.label || def;
              };
              _createClass(_class, [{
                key: "schemaType",
                get: function get() {
                  return this._type;
                }
              }]);
              return _class;
            }();
            internals.Any.prototype.isImmutable = true;
            internals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;
            internals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;
            internals.Any.prototype.exist = internals.Any.prototype.required;
            internals._try = function(fn, args) {
              var err = void 0;
              var result = void 0;
              try {
                result = fn.apply(null, args);
              } catch (e) {
                err = e;
              }
              return {
                value: result,
                error: err
              };
            };
          },
          /* 3 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            (function(global) {
              var base64 = __webpack_require__(33);
              var ieee754 = __webpack_require__(34);
              var isArray = __webpack_require__(35);
              exports2.Buffer = Buffer;
              exports2.SlowBuffer = SlowBuffer;
              exports2.INSPECT_MAX_BYTES = 50;
              Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== void 0 ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
              exports2.kMaxLength = kMaxLength();
              function typedArraySupport() {
                try {
                  var arr = new Uint8Array(1);
                  arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                    return 42;
                  } };
                  return arr.foo() === 42 && // typed array instances can be augmented
                  typeof arr.subarray === "function" && // chrome 9-10 lack `subarray`
                  arr.subarray(1, 1).byteLength === 0;
                } catch (e) {
                  return false;
                }
              }
              function kMaxLength() {
                return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
              }
              function createBuffer(that, length) {
                if (kMaxLength() < length) {
                  throw new RangeError("Invalid typed array length");
                }
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                  that = new Uint8Array(length);
                  that.__proto__ = Buffer.prototype;
                } else {
                  if (that === null) {
                    that = new Buffer(length);
                  }
                  that.length = length;
                }
                return that;
              }
              function Buffer(arg, encodingOrOffset, length) {
                if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                  return new Buffer(arg, encodingOrOffset, length);
                }
                if (typeof arg === "number") {
                  if (typeof encodingOrOffset === "string") {
                    throw new Error(
                      "If encoding is specified then the first argument must be a string"
                    );
                  }
                  return allocUnsafe(this, arg);
                }
                return from(this, arg, encodingOrOffset, length);
              }
              Buffer.poolSize = 8192;
              Buffer._augment = function(arr) {
                arr.__proto__ = Buffer.prototype;
                return arr;
              };
              function from(that, value, encodingOrOffset, length) {
                if (typeof value === "number") {
                  throw new TypeError('"value" argument must not be a number');
                }
                if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
                  return fromArrayBuffer(that, value, encodingOrOffset, length);
                }
                if (typeof value === "string") {
                  return fromString(that, value, encodingOrOffset);
                }
                return fromObject(that, value);
              }
              Buffer.from = function(value, encodingOrOffset, length) {
                return from(null, value, encodingOrOffset, length);
              };
              if (Buffer.TYPED_ARRAY_SUPPORT) {
                Buffer.prototype.__proto__ = Uint8Array.prototype;
                Buffer.__proto__ = Uint8Array;
                if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) {
                  Object.defineProperty(Buffer, Symbol.species, {
                    value: null,
                    configurable: true
                  });
                }
              }
              function assertSize(size) {
                if (typeof size !== "number") {
                  throw new TypeError('"size" argument must be a number');
                } else if (size < 0) {
                  throw new RangeError('"size" argument must not be negative');
                }
              }
              function alloc(that, size, fill, encoding) {
                assertSize(size);
                if (size <= 0) {
                  return createBuffer(that, size);
                }
                if (fill !== void 0) {
                  return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
                }
                return createBuffer(that, size);
              }
              Buffer.alloc = function(size, fill, encoding) {
                return alloc(null, size, fill, encoding);
              };
              function allocUnsafe(that, size) {
                assertSize(size);
                that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
                if (!Buffer.TYPED_ARRAY_SUPPORT) {
                  for (var i = 0; i < size; ++i) {
                    that[i] = 0;
                  }
                }
                return that;
              }
              Buffer.allocUnsafe = function(size) {
                return allocUnsafe(null, size);
              };
              Buffer.allocUnsafeSlow = function(size) {
                return allocUnsafe(null, size);
              };
              function fromString(that, string, encoding) {
                if (typeof encoding !== "string" || encoding === "") {
                  encoding = "utf8";
                }
                if (!Buffer.isEncoding(encoding)) {
                  throw new TypeError('"encoding" must be a valid string encoding');
                }
                var length = byteLength(string, encoding) | 0;
                that = createBuffer(that, length);
                var actual = that.write(string, encoding);
                if (actual !== length) {
                  that = that.slice(0, actual);
                }
                return that;
              }
              function fromArrayLike(that, array) {
                var length = array.length < 0 ? 0 : checked(array.length) | 0;
                that = createBuffer(that, length);
                for (var i = 0; i < length; i += 1) {
                  that[i] = array[i] & 255;
                }
                return that;
              }
              function fromArrayBuffer(that, array, byteOffset, length) {
                array.byteLength;
                if (byteOffset < 0 || array.byteLength < byteOffset) {
                  throw new RangeError("'offset' is out of bounds");
                }
                if (array.byteLength < byteOffset + (length || 0)) {
                  throw new RangeError("'length' is out of bounds");
                }
                if (byteOffset === void 0 && length === void 0) {
                  array = new Uint8Array(array);
                } else if (length === void 0) {
                  array = new Uint8Array(array, byteOffset);
                } else {
                  array = new Uint8Array(array, byteOffset, length);
                }
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                  that = array;
                  that.__proto__ = Buffer.prototype;
                } else {
                  that = fromArrayLike(that, array);
                }
                return that;
              }
              function fromObject(that, obj) {
                if (Buffer.isBuffer(obj)) {
                  var len = checked(obj.length) | 0;
                  that = createBuffer(that, len);
                  if (that.length === 0) {
                    return that;
                  }
                  obj.copy(that, 0, 0, len);
                  return that;
                }
                if (obj) {
                  if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
                    if (typeof obj.length !== "number" || isnan(obj.length)) {
                      return createBuffer(that, 0);
                    }
                    return fromArrayLike(that, obj);
                  }
                  if (obj.type === "Buffer" && isArray(obj.data)) {
                    return fromArrayLike(that, obj.data);
                  }
                }
                throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
              }
              function checked(length) {
                if (length >= kMaxLength()) {
                  throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
                }
                return length | 0;
              }
              function SlowBuffer(length) {
                if (+length != length) {
                  length = 0;
                }
                return Buffer.alloc(+length);
              }
              Buffer.isBuffer = function isBuffer(b) {
                return !!(b != null && b._isBuffer);
              };
              Buffer.compare = function compare(a, b) {
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                  throw new TypeError("Arguments must be Buffers");
                }
                if (a === b)
                  return 0;
                var x = a.length;
                var y = b.length;
                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                  if (a[i] !== b[i]) {
                    x = a[i];
                    y = b[i];
                    break;
                  }
                }
                if (x < y)
                  return -1;
                if (y < x)
                  return 1;
                return 0;
              };
              Buffer.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return true;
                  default:
                    return false;
                }
              };
              Buffer.concat = function concat(list, length) {
                if (!isArray(list)) {
                  throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (list.length === 0) {
                  return Buffer.alloc(0);
                }
                var i;
                if (length === void 0) {
                  length = 0;
                  for (i = 0; i < list.length; ++i) {
                    length += list[i].length;
                  }
                }
                var buffer = Buffer.allocUnsafe(length);
                var pos = 0;
                for (i = 0; i < list.length; ++i) {
                  var buf = list[i];
                  if (!Buffer.isBuffer(buf)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                  }
                  buf.copy(buffer, pos);
                  pos += buf.length;
                }
                return buffer;
              };
              function byteLength(string, encoding) {
                if (Buffer.isBuffer(string)) {
                  return string.length;
                }
                if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                  return string.byteLength;
                }
                if (typeof string !== "string") {
                  string = "" + string;
                }
                var len = string.length;
                if (len === 0)
                  return 0;
                var loweredCase = false;
                for (; ; ) {
                  switch (encoding) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return len;
                    case "utf8":
                    case "utf-8":
                    case void 0:
                      return utf8ToBytes(string).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return len * 2;
                    case "hex":
                      return len >>> 1;
                    case "base64":
                      return base64ToBytes(string).length;
                    default:
                      if (loweredCase)
                        return utf8ToBytes(string).length;
                      encoding = ("" + encoding).toLowerCase();
                      loweredCase = true;
                  }
                }
              }
              Buffer.byteLength = byteLength;
              function slowToString(encoding, start, end) {
                var loweredCase = false;
                if (start === void 0 || start < 0) {
                  start = 0;
                }
                if (start > this.length) {
                  return "";
                }
                if (end === void 0 || end > this.length) {
                  end = this.length;
                }
                if (end <= 0) {
                  return "";
                }
                end >>>= 0;
                start >>>= 0;
                if (end <= start) {
                  return "";
                }
                if (!encoding)
                  encoding = "utf8";
                while (true) {
                  switch (encoding) {
                    case "hex":
                      return hexSlice(this, start, end);
                    case "utf8":
                    case "utf-8":
                      return utf8Slice(this, start, end);
                    case "ascii":
                      return asciiSlice(this, start, end);
                    case "latin1":
                    case "binary":
                      return latin1Slice(this, start, end);
                    case "base64":
                      return base64Slice(this, start, end);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return utf16leSlice(this, start, end);
                    default:
                      if (loweredCase)
                        throw new TypeError("Unknown encoding: " + encoding);
                      encoding = (encoding + "").toLowerCase();
                      loweredCase = true;
                  }
                }
              }
              Buffer.prototype._isBuffer = true;
              function swap(b, n, m) {
                var i = b[n];
                b[n] = b[m];
                b[m] = i;
              }
              Buffer.prototype.swap16 = function swap16() {
                var len = this.length;
                if (len % 2 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for (var i = 0; i < len; i += 2) {
                  swap(this, i, i + 1);
                }
                return this;
              };
              Buffer.prototype.swap32 = function swap32() {
                var len = this.length;
                if (len % 4 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for (var i = 0; i < len; i += 4) {
                  swap(this, i, i + 3);
                  swap(this, i + 1, i + 2);
                }
                return this;
              };
              Buffer.prototype.swap64 = function swap64() {
                var len = this.length;
                if (len % 8 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for (var i = 0; i < len; i += 8) {
                  swap(this, i, i + 7);
                  swap(this, i + 1, i + 6);
                  swap(this, i + 2, i + 5);
                  swap(this, i + 3, i + 4);
                }
                return this;
              };
              Buffer.prototype.toString = function toString() {
                var length = this.length | 0;
                if (length === 0)
                  return "";
                if (arguments.length === 0)
                  return utf8Slice(this, 0, length);
                return slowToString.apply(this, arguments);
              };
              Buffer.prototype.equals = function equals(b) {
                if (!Buffer.isBuffer(b))
                  throw new TypeError("Argument must be a Buffer");
                if (this === b)
                  return true;
                return Buffer.compare(this, b) === 0;
              };
              Buffer.prototype.inspect = function inspect() {
                var str = "";
                var max = exports2.INSPECT_MAX_BYTES;
                if (this.length > 0) {
                  str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
                  if (this.length > max)
                    str += " ... ";
                }
                return "<Buffer " + str + ">";
              };
              Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                if (!Buffer.isBuffer(target)) {
                  throw new TypeError("Argument must be a Buffer");
                }
                if (start === void 0) {
                  start = 0;
                }
                if (end === void 0) {
                  end = target ? target.length : 0;
                }
                if (thisStart === void 0) {
                  thisStart = 0;
                }
                if (thisEnd === void 0) {
                  thisEnd = this.length;
                }
                if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                  throw new RangeError("out of range index");
                }
                if (thisStart >= thisEnd && start >= end) {
                  return 0;
                }
                if (thisStart >= thisEnd) {
                  return -1;
                }
                if (start >= end) {
                  return 1;
                }
                start >>>= 0;
                end >>>= 0;
                thisStart >>>= 0;
                thisEnd >>>= 0;
                if (this === target)
                  return 0;
                var x = thisEnd - thisStart;
                var y = end - start;
                var len = Math.min(x, y);
                var thisCopy = this.slice(thisStart, thisEnd);
                var targetCopy = target.slice(start, end);
                for (var i = 0; i < len; ++i) {
                  if (thisCopy[i] !== targetCopy[i]) {
                    x = thisCopy[i];
                    y = targetCopy[i];
                    break;
                  }
                }
                if (x < y)
                  return -1;
                if (y < x)
                  return 1;
                return 0;
              };
              function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                if (buffer.length === 0)
                  return -1;
                if (typeof byteOffset === "string") {
                  encoding = byteOffset;
                  byteOffset = 0;
                } else if (byteOffset > 2147483647) {
                  byteOffset = 2147483647;
                } else if (byteOffset < -2147483648) {
                  byteOffset = -2147483648;
                }
                byteOffset = +byteOffset;
                if (isNaN(byteOffset)) {
                  byteOffset = dir ? 0 : buffer.length - 1;
                }
                if (byteOffset < 0)
                  byteOffset = buffer.length + byteOffset;
                if (byteOffset >= buffer.length) {
                  if (dir)
                    return -1;
                  else
                    byteOffset = buffer.length - 1;
                } else if (byteOffset < 0) {
                  if (dir)
                    byteOffset = 0;
                  else
                    return -1;
                }
                if (typeof val === "string") {
                  val = Buffer.from(val, encoding);
                }
                if (Buffer.isBuffer(val)) {
                  if (val.length === 0) {
                    return -1;
                  }
                  return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                } else if (typeof val === "number") {
                  val = val & 255;
                  if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
                    if (dir) {
                      return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                    } else {
                      return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                    }
                  }
                  return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                }
                throw new TypeError("val must be string, number or Buffer");
              }
              function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                var indexSize = 1;
                var arrLength = arr.length;
                var valLength = val.length;
                if (encoding !== void 0) {
                  encoding = String(encoding).toLowerCase();
                  if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                    if (arr.length < 2 || val.length < 2) {
                      return -1;
                    }
                    indexSize = 2;
                    arrLength /= 2;
                    valLength /= 2;
                    byteOffset /= 2;
                  }
                }
                function read(buf, i2) {
                  if (indexSize === 1) {
                    return buf[i2];
                  } else {
                    return buf.readUInt16BE(i2 * indexSize);
                  }
                }
                var i;
                if (dir) {
                  var foundIndex = -1;
                  for (i = byteOffset; i < arrLength; i++) {
                    if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                      if (foundIndex === -1)
                        foundIndex = i;
                      if (i - foundIndex + 1 === valLength)
                        return foundIndex * indexSize;
                    } else {
                      if (foundIndex !== -1)
                        i -= i - foundIndex;
                      foundIndex = -1;
                    }
                  }
                } else {
                  if (byteOffset + valLength > arrLength)
                    byteOffset = arrLength - valLength;
                  for (i = byteOffset; i >= 0; i--) {
                    var found = true;
                    for (var j = 0; j < valLength; j++) {
                      if (read(arr, i + j) !== read(val, j)) {
                        found = false;
                        break;
                      }
                    }
                    if (found)
                      return i;
                  }
                }
                return -1;
              }
              Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                return this.indexOf(val, byteOffset, encoding) !== -1;
              };
              Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
              };
              Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
              };
              function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0;
                var remaining = buf.length - offset;
                if (!length) {
                  length = remaining;
                } else {
                  length = Number(length);
                  if (length > remaining) {
                    length = remaining;
                  }
                }
                var strLen = string.length;
                if (strLen % 2 !== 0)
                  throw new TypeError("Invalid hex string");
                if (length > strLen / 2) {
                  length = strLen / 2;
                }
                for (var i = 0; i < length; ++i) {
                  var parsed = parseInt(string.substr(i * 2, 2), 16);
                  if (isNaN(parsed))
                    return i;
                  buf[offset + i] = parsed;
                }
                return i;
              }
              function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
              }
              function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length);
              }
              function latin1Write(buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length);
              }
              function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length);
              }
              function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
              }
              Buffer.prototype.write = function write(string, offset, length, encoding) {
                if (offset === void 0) {
                  encoding = "utf8";
                  length = this.length;
                  offset = 0;
                } else if (length === void 0 && typeof offset === "string") {
                  encoding = offset;
                  length = this.length;
                  offset = 0;
                } else if (isFinite(offset)) {
                  offset = offset | 0;
                  if (isFinite(length)) {
                    length = length | 0;
                    if (encoding === void 0)
                      encoding = "utf8";
                  } else {
                    encoding = length;
                    length = void 0;
                  }
                } else {
                  throw new Error(
                    "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                  );
                }
                var remaining = this.length - offset;
                if (length === void 0 || length > remaining)
                  length = remaining;
                if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                  throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!encoding)
                  encoding = "utf8";
                var loweredCase = false;
                for (; ; ) {
                  switch (encoding) {
                    case "hex":
                      return hexWrite(this, string, offset, length);
                    case "utf8":
                    case "utf-8":
                      return utf8Write(this, string, offset, length);
                    case "ascii":
                      return asciiWrite(this, string, offset, length);
                    case "latin1":
                    case "binary":
                      return latin1Write(this, string, offset, length);
                    case "base64":
                      return base64Write(this, string, offset, length);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return ucs2Write(this, string, offset, length);
                    default:
                      if (loweredCase)
                        throw new TypeError("Unknown encoding: " + encoding);
                      encoding = ("" + encoding).toLowerCase();
                      loweredCase = true;
                  }
                }
              };
              Buffer.prototype.toJSON = function toJSON() {
                return {
                  type: "Buffer",
                  data: Array.prototype.slice.call(this._arr || this, 0)
                };
              };
              function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                  return base64.fromByteArray(buf);
                } else {
                  return base64.fromByteArray(buf.slice(start, end));
                }
              }
              function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end);
                var res = [];
                var i = start;
                while (i < end) {
                  var firstByte = buf[i];
                  var codePoint = null;
                  var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                  if (i + bytesPerSequence <= end) {
                    var secondByte, thirdByte, fourthByte, tempCodePoint;
                    switch (bytesPerSequence) {
                      case 1:
                        if (firstByte < 128) {
                          codePoint = firstByte;
                        }
                        break;
                      case 2:
                        secondByte = buf[i + 1];
                        if ((secondByte & 192) === 128) {
                          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                          if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                          }
                        }
                        break;
                      case 3:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                          }
                        }
                        break;
                      case 4:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        fourthByte = buf[i + 3];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                          }
                        }
                    }
                  }
                  if (codePoint === null) {
                    codePoint = 65533;
                    bytesPerSequence = 1;
                  } else if (codePoint > 65535) {
                    codePoint -= 65536;
                    res.push(codePoint >>> 10 & 1023 | 55296);
                    codePoint = 56320 | codePoint & 1023;
                  }
                  res.push(codePoint);
                  i += bytesPerSequence;
                }
                return decodeCodePointsArray(res);
              }
              var MAX_ARGUMENTS_LENGTH = 4096;
              function decodeCodePointsArray(codePoints) {
                var len = codePoints.length;
                if (len <= MAX_ARGUMENTS_LENGTH) {
                  return String.fromCharCode.apply(String, codePoints);
                }
                var res = "";
                var i = 0;
                while (i < len) {
                  res += String.fromCharCode.apply(
                    String,
                    codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                  );
                }
                return res;
              }
              function asciiSlice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; i < end; ++i) {
                  ret += String.fromCharCode(buf[i] & 127);
                }
                return ret;
              }
              function latin1Slice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; i < end; ++i) {
                  ret += String.fromCharCode(buf[i]);
                }
                return ret;
              }
              function hexSlice(buf, start, end) {
                var len = buf.length;
                if (!start || start < 0)
                  start = 0;
                if (!end || end < 0 || end > len)
                  end = len;
                var out = "";
                for (var i = start; i < end; ++i) {
                  out += toHex(buf[i]);
                }
                return out;
              }
              function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end);
                var res = "";
                for (var i = 0; i < bytes.length; i += 2) {
                  res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                }
                return res;
              }
              Buffer.prototype.slice = function slice(start, end) {
                var len = this.length;
                start = ~~start;
                end = end === void 0 ? len : ~~end;
                if (start < 0) {
                  start += len;
                  if (start < 0)
                    start = 0;
                } else if (start > len) {
                  start = len;
                }
                if (end < 0) {
                  end += len;
                  if (end < 0)
                    end = 0;
                } else if (end > len) {
                  end = len;
                }
                if (end < start)
                  end = start;
                var newBuf;
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                  newBuf = this.subarray(start, end);
                  newBuf.__proto__ = Buffer.prototype;
                } else {
                  var sliceLen = end - start;
                  newBuf = new Buffer(sliceLen, void 0);
                  for (var i = 0; i < sliceLen; ++i) {
                    newBuf[i] = this[i + start];
                  }
                }
                return newBuf;
              };
              function checkOffset(offset, ext, length) {
                if (offset % 1 !== 0 || offset < 0)
                  throw new RangeError("offset is not uint");
                if (offset + ext > length)
                  throw new RangeError("Trying to access beyond buffer length");
              }
              Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert)
                  checkOffset(offset, byteLength2, this.length);
                var val = this[offset];
                var mul = 1;
                var i = 0;
                while (++i < byteLength2 && (mul *= 256)) {
                  val += this[offset + i] * mul;
                }
                return val;
              };
              Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert) {
                  checkOffset(offset, byteLength2, this.length);
                }
                var val = this[offset + --byteLength2];
                var mul = 1;
                while (byteLength2 > 0 && (mul *= 256)) {
                  val += this[offset + --byteLength2] * mul;
                }
                return val;
              };
              Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 1, this.length);
                return this[offset];
              };
              Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 2, this.length);
                return this[offset] | this[offset + 1] << 8;
              };
              Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 2, this.length);
                return this[offset] << 8 | this[offset + 1];
              };
              Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 4, this.length);
                return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
              };
              Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 4, this.length);
                return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
              };
              Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert)
                  checkOffset(offset, byteLength2, this.length);
                var val = this[offset];
                var mul = 1;
                var i = 0;
                while (++i < byteLength2 && (mul *= 256)) {
                  val += this[offset + i] * mul;
                }
                mul *= 128;
                if (val >= mul)
                  val -= Math.pow(2, 8 * byteLength2);
                return val;
              };
              Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert)
                  checkOffset(offset, byteLength2, this.length);
                var i = byteLength2;
                var mul = 1;
                var val = this[offset + --i];
                while (i > 0 && (mul *= 256)) {
                  val += this[offset + --i] * mul;
                }
                mul *= 128;
                if (val >= mul)
                  val -= Math.pow(2, 8 * byteLength2);
                return val;
              };
              Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 1, this.length);
                if (!(this[offset] & 128))
                  return this[offset];
                return (255 - this[offset] + 1) * -1;
              };
              Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 2, this.length);
                var val = this[offset] | this[offset + 1] << 8;
                return val & 32768 ? val | 4294901760 : val;
              };
              Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 2, this.length);
                var val = this[offset + 1] | this[offset] << 8;
                return val & 32768 ? val | 4294901760 : val;
              };
              Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 4, this.length);
                return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
              };
              Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 4, this.length);
                return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
              };
              Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, true, 23, 4);
              };
              Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, false, 23, 4);
              };
              Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, true, 52, 8);
              };
              Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, false, 52, 8);
              };
              function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf))
                  throw new TypeError('"buffer" argument must be a Buffer instance');
                if (value > max || value < min)
                  throw new RangeError('"value" argument is out of bounds');
                if (offset + ext > buf.length)
                  throw new RangeError("Index out of range");
              }
              Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert) {
                  var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                  checkInt(this, value, offset, byteLength2, maxBytes, 0);
                }
                var mul = 1;
                var i = 0;
                this[offset] = value & 255;
                while (++i < byteLength2 && (mul *= 256)) {
                  this[offset + i] = value / mul & 255;
                }
                return offset + byteLength2;
              };
              Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert) {
                  var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                  checkInt(this, value, offset, byteLength2, maxBytes, 0);
                }
                var i = byteLength2 - 1;
                var mul = 1;
                this[offset + i] = value & 255;
                while (--i >= 0 && (mul *= 256)) {
                  this[offset + i] = value / mul & 255;
                }
                return offset + byteLength2;
              };
              Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 1, 255, 0);
                if (!Buffer.TYPED_ARRAY_SUPPORT)
                  value = Math.floor(value);
                this[offset] = value & 255;
                return offset + 1;
              };
              function objectWriteUInt16(buf, value, offset, littleEndian) {
                if (value < 0)
                  value = 65535 + value + 1;
                for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                  buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
                }
              }
              Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 2, 65535, 0);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                } else {
                  objectWriteUInt16(this, value, offset, true);
                }
                return offset + 2;
              };
              Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 2, 65535, 0);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value >>> 8;
                  this[offset + 1] = value & 255;
                } else {
                  objectWriteUInt16(this, value, offset, false);
                }
                return offset + 2;
              };
              function objectWriteUInt32(buf, value, offset, littleEndian) {
                if (value < 0)
                  value = 4294967295 + value + 1;
                for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                  buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
                }
              }
              Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 4, 4294967295, 0);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                  this[offset + 3] = value >>> 24;
                  this[offset + 2] = value >>> 16;
                  this[offset + 1] = value >>> 8;
                  this[offset] = value & 255;
                } else {
                  objectWriteUInt32(this, value, offset, true);
                }
                return offset + 4;
              };
              Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 4, 4294967295, 0);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value >>> 24;
                  this[offset + 1] = value >>> 16;
                  this[offset + 2] = value >>> 8;
                  this[offset + 3] = value & 255;
                } else {
                  objectWriteUInt32(this, value, offset, false);
                }
                return offset + 4;
              };
              Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) {
                  var limit = Math.pow(2, 8 * byteLength2 - 1);
                  checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                }
                var i = 0;
                var mul = 1;
                var sub = 0;
                this[offset] = value & 255;
                while (++i < byteLength2 && (mul *= 256)) {
                  if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                    sub = 1;
                  }
                  this[offset + i] = (value / mul >> 0) - sub & 255;
                }
                return offset + byteLength2;
              };
              Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) {
                  var limit = Math.pow(2, 8 * byteLength2 - 1);
                  checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                }
                var i = byteLength2 - 1;
                var mul = 1;
                var sub = 0;
                this[offset + i] = value & 255;
                while (--i >= 0 && (mul *= 256)) {
                  if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                    sub = 1;
                  }
                  this[offset + i] = (value / mul >> 0) - sub & 255;
                }
                return offset + byteLength2;
              };
              Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 1, 127, -128);
                if (!Buffer.TYPED_ARRAY_SUPPORT)
                  value = Math.floor(value);
                if (value < 0)
                  value = 255 + value + 1;
                this[offset] = value & 255;
                return offset + 1;
              };
              Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 2, 32767, -32768);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                } else {
                  objectWriteUInt16(this, value, offset, true);
                }
                return offset + 2;
              };
              Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 2, 32767, -32768);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value >>> 8;
                  this[offset + 1] = value & 255;
                } else {
                  objectWriteUInt16(this, value, offset, false);
                }
                return offset + 2;
              };
              Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 4, 2147483647, -2147483648);
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                  this[offset + 2] = value >>> 16;
                  this[offset + 3] = value >>> 24;
                } else {
                  objectWriteUInt32(this, value, offset, true);
                }
                return offset + 4;
              };
              Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 4, 2147483647, -2147483648);
                if (value < 0)
                  value = 4294967295 + value + 1;
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value >>> 24;
                  this[offset + 1] = value >>> 16;
                  this[offset + 2] = value >>> 8;
                  this[offset + 3] = value & 255;
                } else {
                  objectWriteUInt32(this, value, offset, false);
                }
                return offset + 4;
              };
              function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length)
                  throw new RangeError("Index out of range");
                if (offset < 0)
                  throw new RangeError("Index out of range");
              }
              function writeFloat(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                  checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4);
                return offset + 4;
              }
              Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                return writeFloat(this, value, offset, true, noAssert);
              };
              Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                return writeFloat(this, value, offset, false, noAssert);
              };
              function writeDouble(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                  checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8);
                return offset + 8;
              }
              Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                return writeDouble(this, value, offset, true, noAssert);
              };
              Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                return writeDouble(this, value, offset, false, noAssert);
              };
              Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                if (!start)
                  start = 0;
                if (!end && end !== 0)
                  end = this.length;
                if (targetStart >= target.length)
                  targetStart = target.length;
                if (!targetStart)
                  targetStart = 0;
                if (end > 0 && end < start)
                  end = start;
                if (end === start)
                  return 0;
                if (target.length === 0 || this.length === 0)
                  return 0;
                if (targetStart < 0) {
                  throw new RangeError("targetStart out of bounds");
                }
                if (start < 0 || start >= this.length)
                  throw new RangeError("sourceStart out of bounds");
                if (end < 0)
                  throw new RangeError("sourceEnd out of bounds");
                if (end > this.length)
                  end = this.length;
                if (target.length - targetStart < end - start) {
                  end = target.length - targetStart + start;
                }
                var len = end - start;
                var i;
                if (this === target && start < targetStart && targetStart < end) {
                  for (i = len - 1; i >= 0; --i) {
                    target[i + targetStart] = this[i + start];
                  }
                } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
                  for (i = 0; i < len; ++i) {
                    target[i + targetStart] = this[i + start];
                  }
                } else {
                  Uint8Array.prototype.set.call(
                    target,
                    this.subarray(start, start + len),
                    targetStart
                  );
                }
                return len;
              };
              Buffer.prototype.fill = function fill(val, start, end, encoding) {
                if (typeof val === "string") {
                  if (typeof start === "string") {
                    encoding = start;
                    start = 0;
                    end = this.length;
                  } else if (typeof end === "string") {
                    encoding = end;
                    end = this.length;
                  }
                  if (val.length === 1) {
                    var code = val.charCodeAt(0);
                    if (code < 256) {
                      val = code;
                    }
                  }
                  if (encoding !== void 0 && typeof encoding !== "string") {
                    throw new TypeError("encoding must be a string");
                  }
                  if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                    throw new TypeError("Unknown encoding: " + encoding);
                  }
                } else if (typeof val === "number") {
                  val = val & 255;
                }
                if (start < 0 || this.length < start || this.length < end) {
                  throw new RangeError("Out of range index");
                }
                if (end <= start) {
                  return this;
                }
                start = start >>> 0;
                end = end === void 0 ? this.length : end >>> 0;
                if (!val)
                  val = 0;
                var i;
                if (typeof val === "number") {
                  for (i = start; i < end; ++i) {
                    this[i] = val;
                  }
                } else {
                  var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
                  var len = bytes.length;
                  for (i = 0; i < end - start; ++i) {
                    this[i + start] = bytes[i % len];
                  }
                }
                return this;
              };
              var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
              function base64clean(str) {
                str = stringtrim(str).replace(INVALID_BASE64_RE, "");
                if (str.length < 2)
                  return "";
                while (str.length % 4 !== 0) {
                  str = str + "=";
                }
                return str;
              }
              function stringtrim(str) {
                if (str.trim)
                  return str.trim();
                return str.replace(/^\s+|\s+$/g, "");
              }
              function toHex(n) {
                if (n < 16)
                  return "0" + n.toString(16);
                return n.toString(16);
              }
              function utf8ToBytes(string, units) {
                units = units || Infinity;
                var codePoint;
                var length = string.length;
                var leadSurrogate = null;
                var bytes = [];
                for (var i = 0; i < length; ++i) {
                  codePoint = string.charCodeAt(i);
                  if (codePoint > 55295 && codePoint < 57344) {
                    if (!leadSurrogate) {
                      if (codePoint > 56319) {
                        if ((units -= 3) > -1)
                          bytes.push(239, 191, 189);
                        continue;
                      } else if (i + 1 === length) {
                        if ((units -= 3) > -1)
                          bytes.push(239, 191, 189);
                        continue;
                      }
                      leadSurrogate = codePoint;
                      continue;
                    }
                    if (codePoint < 56320) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      leadSurrogate = codePoint;
                      continue;
                    }
                    codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                  } else if (leadSurrogate) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                  }
                  leadSurrogate = null;
                  if (codePoint < 128) {
                    if ((units -= 1) < 0)
                      break;
                    bytes.push(codePoint);
                  } else if (codePoint < 2048) {
                    if ((units -= 2) < 0)
                      break;
                    bytes.push(
                      codePoint >> 6 | 192,
                      codePoint & 63 | 128
                    );
                  } else if (codePoint < 65536) {
                    if ((units -= 3) < 0)
                      break;
                    bytes.push(
                      codePoint >> 12 | 224,
                      codePoint >> 6 & 63 | 128,
                      codePoint & 63 | 128
                    );
                  } else if (codePoint < 1114112) {
                    if ((units -= 4) < 0)
                      break;
                    bytes.push(
                      codePoint >> 18 | 240,
                      codePoint >> 12 & 63 | 128,
                      codePoint >> 6 & 63 | 128,
                      codePoint & 63 | 128
                    );
                  } else {
                    throw new Error("Invalid code point");
                  }
                }
                return bytes;
              }
              function asciiToBytes(str) {
                var byteArray = [];
                for (var i = 0; i < str.length; ++i) {
                  byteArray.push(str.charCodeAt(i) & 255);
                }
                return byteArray;
              }
              function utf16leToBytes(str, units) {
                var c, hi, lo;
                var byteArray = [];
                for (var i = 0; i < str.length; ++i) {
                  if ((units -= 2) < 0)
                    break;
                  c = str.charCodeAt(i);
                  hi = c >> 8;
                  lo = c % 256;
                  byteArray.push(lo);
                  byteArray.push(hi);
                }
                return byteArray;
              }
              function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str));
              }
              function blitBuffer(src, dst, offset, length) {
                for (var i = 0; i < length; ++i) {
                  if (i + offset >= dst.length || i >= src.length)
                    break;
                  dst[i + offset] = src[i];
                }
                return i;
              }
              function isnan(val) {
                return val !== val;
              }
            }).call(exports2, __webpack_require__(5));
          },
          /* 4 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var Hoek = __webpack_require__(0);
            var Ref = __webpack_require__(1);
            var internals = {};
            exports2.schema = function(Joi, config) {
              if (config !== void 0 && config !== null && (typeof config === "undefined" ? "undefined" : _typeof(config)) === "object") {
                if (config.isJoi) {
                  return config;
                }
                if (Array.isArray(config)) {
                  return Joi.alternatives().try(config);
                }
                if (config instanceof RegExp) {
                  return Joi.string().regex(config);
                }
                if (config instanceof Date) {
                  return Joi.date().valid(config);
                }
                return Joi.object().keys(config);
              }
              if (typeof config === "string") {
                return Joi.string().valid(config);
              }
              if (typeof config === "number") {
                return Joi.number().valid(config);
              }
              if (typeof config === "boolean") {
                return Joi.boolean().valid(config);
              }
              if (Ref.isRef(config)) {
                return Joi.valid(config);
              }
              Hoek.assert(config === null, "Invalid schema content:", config);
              return Joi.valid(null);
            };
            exports2.ref = function(id) {
              return Ref.isRef(id) ? id : Ref.create(id);
            };
          },
          /* 5 */
          /***/
          function(module2, exports2) {
            var g;
            g = function() {
              return this;
            }();
            try {
              g = g || Function("return this")() || (1, eval)("this");
            } catch (e) {
              if (typeof window === "object")
                g = window;
            }
            module2.exports = g;
          },
          /* 6 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Hoek = __webpack_require__(0);
            var Language = __webpack_require__(20);
            var internals = {
              annotations: Symbol("joi-annotations")
            };
            internals.stringify = function(value, wrapArrays) {
              var type = typeof value === "undefined" ? "undefined" : _typeof(value);
              if (value === null) {
                return "null";
              }
              if (type === "string") {
                return value;
              }
              if (value instanceof exports2.Err || type === "function" || type === "symbol") {
                return value.toString();
              }
              if (type === "object") {
                if (Array.isArray(value)) {
                  var partial = "";
                  for (var i = 0; i < value.length; ++i) {
                    partial = partial + (partial.length ? ", " : "") + internals.stringify(value[i], wrapArrays);
                  }
                  return wrapArrays ? "[" + partial + "]" : partial;
                }
                return value.toString();
              }
              return JSON.stringify(value);
            };
            exports2.Err = function() {
              function _class(type, context, state, options, flags, message, template) {
                _classCallCheck(this, _class);
                this.isJoi = true;
                this.type = type;
                this.context = context || {};
                this.context.key = state.path[state.path.length - 1];
                this.context.label = state.key;
                this.path = state.path;
                this.options = options;
                this.flags = flags;
                this.message = message;
                this.template = template;
                var localized = this.options.language;
                if (this.flags.label) {
                  this.context.label = this.flags.label;
                } else if (localized && // language can be null for arrays exclusion check
                (this.context.label === "" || this.context.label === null)) {
                  this.context.label = localized.root || Language.errors.root;
                }
              }
              _class.prototype.toString = function toString() {
                var _this = this;
                if (this.message) {
                  return this.message;
                }
                var format = void 0;
                if (this.template) {
                  format = this.template;
                }
                var localized = this.options.language;
                format = format || Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);
                if (format === void 0) {
                  return 'Error code "' + this.type + '" is not defined, your custom type is missing the correct language definition';
                }
                var wrapArrays = Hoek.reach(localized, "messages.wrapArrays");
                if (typeof wrapArrays !== "boolean") {
                  wrapArrays = Language.errors.messages.wrapArrays;
                }
                if (format === null) {
                  var childrenString = internals.stringify(this.context.reason, wrapArrays);
                  if (wrapArrays) {
                    return childrenString.slice(1, -1);
                  }
                  return childrenString;
                }
                var hasKey = /\{\{\!?label\}\}/.test(format);
                var skipKey = format.length > 2 && format[0] === "!" && format[1] === "!";
                if (skipKey) {
                  format = format.slice(2);
                }
                if (!hasKey && !skipKey) {
                  var localizedKey = Hoek.reach(localized, "key");
                  if (typeof localizedKey === "string") {
                    format = localizedKey + format;
                  } else {
                    format = Hoek.reach(Language.errors, "key") + format;
                  }
                }
                return format.replace(/\{\{(\!?)([^}]+)\}\}/g, function($0, isSecure, name) {
                  var value = Hoek.reach(_this.context, name);
                  var normalized = internals.stringify(value, wrapArrays);
                  return isSecure && _this.options.escapeHtml ? Hoek.escapeHtml(normalized) : normalized;
                });
              };
              return _class;
            }();
            exports2.create = function(type, context, state, options, flags, message, template) {
              return new exports2.Err(type, context, state, options, flags, message, template);
            };
            exports2.process = function(errors, object) {
              if (!errors || !errors.length) {
                return null;
              }
              var message = "";
              var details = [];
              var processErrors = function processErrors2(localErrors, parent) {
                for (var i = 0; i < localErrors.length; ++i) {
                  var item = localErrors[i];
                  if (item instanceof Error) {
                    return item;
                  }
                  if (item.flags.error && typeof item.flags.error !== "function") {
                    return item.flags.error;
                  }
                  var itemMessage = void 0;
                  if (parent === void 0) {
                    itemMessage = item.toString();
                    message = message + (message ? ". " : "") + itemMessage;
                  }
                  if (item.context.reason && item.context.reason.length) {
                    var _override = processErrors2(item.context.reason, item.path);
                    if (_override) {
                      return _override;
                    }
                  } else {
                    details.push({
                      message: itemMessage || item.toString(),
                      path: item.path,
                      type: item.type,
                      context: item.context
                    });
                  }
                }
              };
              var override = processErrors(errors);
              if (override) {
                return override;
              }
              var error = new Error(message);
              error.isJoi = true;
              error.name = "ValidationError";
              error.details = details;
              error._object = object;
              error.annotate = internals.annotate;
              return error;
            };
            internals.safeStringify = function(obj, spaces) {
              return JSON.stringify(obj, internals.serializer(), spaces);
            };
            internals.serializer = function() {
              var keys = [];
              var stack = [];
              var cycleReplacer = function cycleReplacer2(key, value) {
                if (stack[0] === value) {
                  return "[Circular ~]";
                }
                return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
              };
              return function(key, value) {
                if (stack.length > 0) {
                  var thisPos = stack.indexOf(this);
                  if (~thisPos) {
                    stack.length = thisPos + 1;
                    keys.length = thisPos + 1;
                    keys[thisPos] = key;
                  } else {
                    stack.push(this);
                    keys.push(key);
                  }
                  if (~stack.indexOf(value)) {
                    value = cycleReplacer.call(this, key, value);
                  }
                } else {
                  stack.push(value);
                }
                if (value) {
                  var annotations = value[internals.annotations];
                  if (annotations) {
                    if (Array.isArray(value)) {
                      var annotated = [];
                      for (var i = 0; i < value.length; ++i) {
                        if (annotations.errors[i]) {
                          annotated.push("_$idx$_" + annotations.errors[i].sort().join(", ") + "_$end$_");
                        }
                        annotated.push(value[i]);
                      }
                      value = annotated;
                    } else {
                      var errorKeys = Object.keys(annotations.errors);
                      for (var _i = 0; _i < errorKeys.length; ++_i) {
                        var errorKey = errorKeys[_i];
                        value[errorKey + "_$key$_" + annotations.errors[errorKey].sort().join(", ") + "_$end$_"] = value[errorKey];
                        value[errorKey] = void 0;
                      }
                      var missingKeys = Object.keys(annotations.missing);
                      for (var _i2 = 0; _i2 < missingKeys.length; ++_i2) {
                        var missingKey = missingKeys[_i2];
                        value["_$miss$_" + missingKey + "|" + annotations.missing[missingKey] + "_$end$_"] = "__missing__";
                      }
                    }
                    return value;
                  }
                }
                if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || (typeof value === "undefined" ? "undefined" : _typeof(value)) === "symbol") {
                  return "[" + value.toString() + "]";
                }
                return value;
              };
            };
            internals.annotate = function(stripColorCodes) {
              var redFgEscape = stripColorCodes ? "" : "\x1B[31m";
              var redBgEscape = stripColorCodes ? "" : "\x1B[41m";
              var endColor = stripColorCodes ? "" : "\x1B[0m";
              if (_typeof(this._object) !== "object") {
                return this.details[0].message;
              }
              var obj = Hoek.clone(this._object || {});
              for (var i = this.details.length - 1; i >= 0; --i) {
                var pos = i + 1;
                var error = this.details[i];
                var path = error.path;
                var ref = obj;
                for (var j = 0; ; ++j) {
                  var seg = path[j];
                  if (ref.isImmutable) {
                    ref = ref.clone();
                  }
                  if (j + 1 < path.length && ref[seg] && typeof ref[seg] !== "string") {
                    ref = ref[seg];
                  } else {
                    var refAnnotations = ref[internals.annotations] = ref[internals.annotations] || { errors: {}, missing: {} };
                    var value = ref[seg];
                    var cacheKey = seg || error.context.label;
                    if (value !== void 0) {
                      refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
                      refAnnotations.errors[cacheKey].push(pos);
                    } else {
                      refAnnotations.missing[cacheKey] = pos;
                    }
                    break;
                  }
                }
              }
              var replacers = {
                key: /_\$key\$_([, \d]+)_\$end\$_\"/g,
                missing: /\"_\$miss\$_([^\|]+)\|(\d+)_\$end\$_\"\: \"__missing__\"/g,
                arrayIndex: /\s*\"_\$idx\$_([, \d]+)_\$end\$_\",?\n(.*)/g,
                specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)\]"/g
              };
              var message = internals.safeStringify(obj, 2).replace(replacers.key, function($0, $1) {
                return '" ' + redFgEscape + "[" + $1 + "]" + endColor;
              }).replace(replacers.missing, function($0, $1, $2) {
                return redBgEscape + '"' + $1 + '"' + endColor + redFgEscape + " [" + $2 + "]: -- missing --" + endColor;
              }).replace(replacers.arrayIndex, function($0, $1, $2) {
                return "\n" + $2 + " " + redFgEscape + "[" + $1 + "]" + endColor;
              }).replace(replacers.specials, function($0, $1) {
                return $1;
              });
              message = message + "\n" + redFgEscape;
              for (var _i3 = 0; _i3 < this.details.length; ++_i3) {
                var _pos = _i3 + 1;
                message = message + "\n[" + _pos + "] " + this.details[_i3].message;
              }
              message = message + endColor;
              return message;
            };
          },
          /* 7 */
          /***/
          function(module2, exports2) {
            var process = module2.exports = {};
            var cachedSetTimeout;
            var cachedClearTimeout;
            function defaultSetTimout() {
              throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
              throw new Error("clearTimeout has not been defined");
            }
            (function() {
              try {
                if (typeof setTimeout === "function") {
                  cachedSetTimeout = setTimeout;
                } else {
                  cachedSetTimeout = defaultSetTimout;
                }
              } catch (e) {
                cachedSetTimeout = defaultSetTimout;
              }
              try {
                if (typeof clearTimeout === "function") {
                  cachedClearTimeout = clearTimeout;
                } else {
                  cachedClearTimeout = defaultClearTimeout;
                }
              } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
              }
            })();
            function runTimeout(fun) {
              if (cachedSetTimeout === setTimeout) {
                return setTimeout(fun, 0);
              }
              if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
              }
              try {
                return cachedSetTimeout(fun, 0);
              } catch (e) {
                try {
                  return cachedSetTimeout.call(null, fun, 0);
                } catch (e2) {
                  return cachedSetTimeout.call(this, fun, 0);
                }
              }
            }
            function runClearTimeout(marker) {
              if (cachedClearTimeout === clearTimeout) {
                return clearTimeout(marker);
              }
              if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
              }
              try {
                return cachedClearTimeout(marker);
              } catch (e) {
                try {
                  return cachedClearTimeout.call(null, marker);
                } catch (e2) {
                  return cachedClearTimeout.call(this, marker);
                }
              }
            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;
            function cleanUpNextTick() {
              if (!draining || !currentQueue) {
                return;
              }
              draining = false;
              if (currentQueue.length) {
                queue = currentQueue.concat(queue);
              } else {
                queueIndex = -1;
              }
              if (queue.length) {
                drainQueue();
              }
            }
            function drainQueue() {
              if (draining) {
                return;
              }
              var timeout = runTimeout(cleanUpNextTick);
              draining = true;
              var len = queue.length;
              while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                  if (currentQueue) {
                    currentQueue[queueIndex].run();
                  }
                }
                queueIndex = -1;
                len = queue.length;
              }
              currentQueue = null;
              draining = false;
              runClearTimeout(timeout);
            }
            process.nextTick = function(fun) {
              var args = new Array(arguments.length - 1);
              if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                  args[i - 1] = arguments[i];
                }
              }
              queue.push(new Item(fun, args));
              if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
              }
            };
            function Item(fun, array) {
              this.fun = fun;
              this.array = array;
            }
            Item.prototype.run = function() {
              this.fun.apply(null, this.array);
            };
            process.title = "browser";
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = "";
            process.versions = {};
            function noop() {
            }
            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;
            process.prependListener = noop;
            process.prependOnceListener = noop;
            process.listeners = function(name) {
              return [];
            };
            process.binding = function(name) {
              throw new Error("process.binding is not supported");
            };
            process.cwd = function() {
              return "/";
            };
            process.chdir = function(dir) {
              throw new Error("process.chdir is not supported");
            };
            process.umask = function() {
              return 0;
            };
          },
          /* 8 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            function _defaults(obj, defaults) {
              var keys = Object.getOwnPropertyNames(defaults);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = Object.getOwnPropertyDescriptor(defaults, key);
                if (value && value.configurable && obj[key] === void 0) {
                  Object.defineProperty(obj, key, value);
                }
              }
              return obj;
            }
            function _defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self, call) {
              if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
            }
            function _toConsumableArray(arr) {
              if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                  arr2[i] = arr[i];
                }
                return arr2;
              } else {
                return Array.from(arr);
              }
            }
            var Hoek = __webpack_require__(0);
            var Any = __webpack_require__(2);
            var Cast = __webpack_require__(4);
            var Errors = __webpack_require__(6);
            var Lazy = __webpack_require__(26);
            var Ref = __webpack_require__(1);
            var Settings = __webpack_require__(11);
            var internals = {
              alternatives: __webpack_require__(10),
              array: __webpack_require__(22),
              boolean: __webpack_require__(24),
              binary: __webpack_require__(23),
              date: __webpack_require__(12),
              func: __webpack_require__(25),
              number: __webpack_require__(27),
              object: __webpack_require__(13),
              string: __webpack_require__(28)
            };
            internals.callWithDefaults = function(schema, args) {
              var _schema;
              Hoek.assert(this, "Must be invoked on a Joi instance.");
              if (this._defaults) {
                schema = this._defaults(schema);
              }
              schema._currentJoi = this;
              return (_schema = schema)._init.apply(_schema, _toConsumableArray(args));
            };
            internals.root = function() {
              var any = new Any();
              var root = any.clone();
              Any.prototype._currentJoi = root;
              root._currentJoi = root;
              root.any = function() {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                Hoek.assert(args.length === 0, "Joi.any() does not allow arguments.");
                return internals.callWithDefaults.call(this, any, args);
              };
              root.alternatives = root.alt = function() {
                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                return internals.callWithDefaults.call(this, internals.alternatives, args);
              };
              root.array = function() {
                for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = arguments[_key3];
                }
                Hoek.assert(args.length === 0, "Joi.array() does not allow arguments.");
                return internals.callWithDefaults.call(this, internals.array, args);
              };
              root.boolean = root.bool = function() {
                for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                  args[_key4] = arguments[_key4];
                }
                Hoek.assert(args.length === 0, "Joi.boolean() does not allow arguments.");
                return internals.callWithDefaults.call(this, internals.boolean, args);
              };
              root.binary = function() {
                for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                  args[_key5] = arguments[_key5];
                }
                Hoek.assert(args.length === 0, "Joi.binary() does not allow arguments.");
                return internals.callWithDefaults.call(this, internals.binary, args);
              };
              root.date = function() {
                for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                  args[_key6] = arguments[_key6];
                }
                Hoek.assert(args.length === 0, "Joi.date() does not allow arguments.");
                return internals.callWithDefaults.call(this, internals.date, args);
              };
              root.func = function() {
                for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
                  args[_key7] = arguments[_key7];
                }
                Hoek.assert(args.length === 0, "Joi.func() does not allow arguments.");
                return internals.callWithDefaults.call(this, internals.func, args);
              };
              root.number = function() {
                for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
                  args[_key8] = arguments[_key8];
                }
                Hoek.assert(args.length === 0, "Joi.number() does not allow arguments.");
                return internals.callWithDefaults.call(this, internals.number, args);
              };
              root.object = function() {
                for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
                  args[_key9] = arguments[_key9];
                }
                return internals.callWithDefaults.call(this, internals.object, args);
              };
              root.string = function() {
                for (var _len10 = arguments.length, args = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
                  args[_key10] = arguments[_key10];
                }
                Hoek.assert(args.length === 0, "Joi.string() does not allow arguments.");
                return internals.callWithDefaults.call(this, internals.string, args);
              };
              root.ref = function() {
                return Ref.create.apply(Ref, arguments);
              };
              root.isRef = function(ref) {
                return Ref.isRef(ref);
              };
              root.validate = function(value) {
                var _ref;
                var last = (_ref = (arguments.length <= 1 ? 0 : arguments.length - 1) - 1 + 1, arguments.length <= _ref ? void 0 : arguments[_ref]);
                var callback = typeof last === "function" ? last : null;
                var count = (arguments.length <= 1 ? 0 : arguments.length - 1) - (callback ? 1 : 0);
                if (count === 0) {
                  return any.validate(value, callback);
                }
                var options = count === 2 ? arguments.length <= 2 ? void 0 : arguments[2] : {};
                var schema = root.compile(arguments.length <= 1 ? void 0 : arguments[1]);
                return schema._validateWithOptions(value, options, callback);
              };
              root.describe = function() {
                var schema = arguments.length ? root.compile(arguments.length <= 0 ? void 0 : arguments[0]) : any;
                return schema.describe();
              };
              root.compile = function(schema) {
                try {
                  return Cast.schema(this, schema);
                } catch (err) {
                  if (err.hasOwnProperty("path")) {
                    err.message = err.message + "(" + err.path + ")";
                  }
                  throw err;
                }
              };
              root.assert = function(value, schema, message) {
                root.attempt(value, schema, message);
              };
              root.attempt = function(value, schema, message) {
                var result = root.validate(value, schema);
                var error = result.error;
                if (error) {
                  if (!message) {
                    if (typeof error.annotate === "function") {
                      error.message = error.annotate();
                    }
                    throw error;
                  }
                  if (!(message instanceof Error)) {
                    if (typeof error.annotate === "function") {
                      error.message = message + " " + error.annotate();
                    }
                    throw error;
                  }
                  throw message;
                }
                return result.value;
              };
              root.reach = function(schema, path) {
                Hoek.assert(schema && schema instanceof Any, "you must provide a joi schema");
                Hoek.assert(Array.isArray(path) || typeof path === "string", "path must be a string or an array of strings");
                var reach = function reach2(sourceSchema, schemaPath2) {
                  if (!schemaPath2.length) {
                    return sourceSchema;
                  }
                  var children = sourceSchema._inner.children;
                  if (!children) {
                    return;
                  }
                  var key = schemaPath2.shift();
                  for (var i = 0; i < children.length; ++i) {
                    var child = children[i];
                    if (child.key === key) {
                      return reach2(child.schema, schemaPath2);
                    }
                  }
                };
                var schemaPath = typeof path === "string" ? path ? path.split(".") : [] : path.slice();
                return reach(schema, schemaPath);
              };
              root.lazy = function(fn) {
                return Lazy.set(fn);
              };
              root.defaults = function(fn) {
                var _this = this;
                Hoek.assert(typeof fn === "function", "Defaults must be a function");
                var joi = Object.create(this.any());
                joi = fn(joi);
                Hoek.assert(joi && joi instanceof this.constructor, "defaults() must return a schema");
                _extends(joi, this, joi.clone());
                joi._defaults = function(schema) {
                  if (_this._defaults) {
                    schema = _this._defaults(schema);
                    Hoek.assert(schema instanceof _this.constructor, "defaults() must return a schema");
                  }
                  schema = fn(schema);
                  Hoek.assert(schema instanceof _this.constructor, "defaults() must return a schema");
                  return schema;
                };
                return joi;
              };
              root.extend = function() {
                var _this2 = this;
                for (var _len11 = arguments.length, args = Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
                  args[_key11] = arguments[_key11];
                }
                var extensions = Hoek.flatten(args);
                Hoek.assert(extensions.length > 0, "You need to provide at least one extension");
                this.assert(extensions, root.extensionsSchema);
                var joi = Object.create(this.any());
                _extends(joi, this);
                var _loop = function _loop2(i2) {
                  var extension = extensions[i2];
                  if (typeof extension === "function") {
                    extension = extension(joi);
                  }
                  _this2.assert(extension, root.extensionSchema);
                  var base = (extension.base || _this2.any()).clone();
                  var ctor = base.constructor;
                  var type = function(_ctor) {
                    _inherits(type2, _ctor);
                    function type2() {
                      _classCallCheck(this, type2);
                      var _this3 = _possibleConstructorReturn(this, _ctor.call(this));
                      if (extension.base) {
                        _extends(_this3, base);
                      }
                      _this3._type = extension.name;
                      if (extension.language) {
                        _this3._settings = Settings.concat(_this3._settings, {
                          language: _defineProperty({}, extension.name, extension.language)
                        });
                      }
                      return _this3;
                    }
                    return type2;
                  }(ctor);
                  if (extension.coerce) {
                    type.prototype._coerce = function(value, state, options) {
                      if (ctor.prototype._coerce) {
                        var baseRet = ctor.prototype._coerce.call(this, value, state, options);
                        if (baseRet.errors) {
                          return baseRet;
                        }
                        value = baseRet.value;
                      }
                      var ret = extension.coerce.call(this, value, state, options);
                      if (ret instanceof Errors.Err) {
                        return { value, errors: ret };
                      }
                      return { value: ret };
                    };
                  }
                  if (extension.pre) {
                    type.prototype._base = function(value, state, options) {
                      if (ctor.prototype._base) {
                        var baseRet = ctor.prototype._base.call(this, value, state, options);
                        if (baseRet.errors) {
                          return baseRet;
                        }
                        value = baseRet.value;
                      }
                      var ret = extension.pre.call(this, value, state, options);
                      if (ret instanceof Errors.Err) {
                        return { value, errors: ret };
                      }
                      return { value: ret };
                    };
                  }
                  if (extension.rules) {
                    var _loop22 = function _loop23(j2) {
                      var rule = extension.rules[j2];
                      var ruleArgs = rule.params ? rule.params instanceof Any ? rule.params._inner.children.map(function(k) {
                        return k.key;
                      }) : Object.keys(rule.params) : [];
                      var validateArgs = rule.params ? Cast.schema(_this2, rule.params) : null;
                      type.prototype[rule.name] = function() {
                        for (var _len12 = arguments.length, rArgs = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
                          rArgs[_key12] = arguments[_key12];
                        }
                        if (rArgs.length > ruleArgs.length) {
                          throw new Error("Unexpected number of arguments");
                        }
                        var hasRef = false;
                        var arg = {};
                        for (var k = 0; k < ruleArgs.length; ++k) {
                          arg[ruleArgs[k]] = rArgs[k];
                          if (!hasRef && Ref.isRef(rArgs[k])) {
                            hasRef = true;
                          }
                        }
                        if (validateArgs) {
                          arg = joi.attempt(arg, validateArgs);
                        }
                        var schema = void 0;
                        if (rule.validate) {
                          var validate = function validate2(value, state, options) {
                            return rule.validate.call(this, arg, value, state, options);
                          };
                          schema = this._test(rule.name, arg, validate, {
                            description: rule.description,
                            hasRef
                          });
                        } else {
                          schema = this.clone();
                        }
                        if (rule.setup) {
                          var newSchema = rule.setup.call(schema, arg);
                          if (newSchema !== void 0) {
                            Hoek.assert(newSchema instanceof Any, "Setup of extension Joi." + this._type + "()." + rule.name + "() must return undefined or a Joi object");
                            schema = newSchema;
                          }
                        }
                        return schema;
                      };
                    };
                    for (var j = 0; j < extension.rules.length; ++j) {
                      _loop22(j);
                    }
                  }
                  if (extension.describe) {
                    type.prototype.describe = function() {
                      var description = ctor.prototype.describe.call(this);
                      return extension.describe.call(this, description);
                    };
                  }
                  var instance = new type();
                  joi[extension.name] = function() {
                    for (var _len13 = arguments.length, extArgs = Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
                      extArgs[_key13] = arguments[_key13];
                    }
                    return internals.callWithDefaults.call(this, instance, extArgs);
                  };
                };
                for (var i = 0; i < extensions.length; ++i) {
                  _loop(i);
                }
                return joi;
              };
              root.extensionSchema = internals.object.keys({
                base: internals.object.type(Any, "Joi object"),
                name: internals.string.required(),
                coerce: internals.func.arity(3),
                pre: internals.func.arity(3),
                language: internals.object,
                describe: internals.func.arity(1),
                rules: internals.array.items(internals.object.keys({
                  name: internals.string.required(),
                  setup: internals.func.arity(1),
                  validate: internals.func.arity(4),
                  params: [internals.object.pattern(/.*/, internals.object.type(Any, "Joi object")), internals.object.type(internals.object.constructor, "Joi object")],
                  description: [internals.string, internals.func.arity(1)]
                }).or("setup", "validate"))
              }).strict();
              root.extensionsSchema = internals.array.items([internals.object, internals.func.arity(1)]).strict();
              root.version = __webpack_require__(36).version;
              return root;
            };
            module2.exports = internals.root();
          },
          /* 9 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            (function(Buffer) {
              var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                return typeof obj;
              } : function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              };
              function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                  for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                    arr2[i] = arr[i];
                  }
                  return arr2;
                } else {
                  return Array.from(arr);
                }
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var Ref = __webpack_require__(1);
              var internals = {};
              internals.extendedCheckForValue = function(value, insensitive) {
                var valueType = typeof value === "undefined" ? "undefined" : _typeof(value);
                if (valueType === "object") {
                  if (value instanceof Date) {
                    return function(item) {
                      return item instanceof Date && value.getTime() === item.getTime();
                    };
                  }
                  if (Buffer.isBuffer(value)) {
                    return function(item) {
                      return Buffer.isBuffer(item) && value.length === item.length && value.toString("binary") === item.toString("binary");
                    };
                  }
                } else if (insensitive && valueType === "string") {
                  var lowercaseValue = value.toLowerCase();
                  return function(item) {
                    return typeof item === "string" && lowercaseValue === item.toLowerCase();
                  };
                }
                return null;
              };
              module2.exports = function() {
                function InternalSet(from) {
                  _classCallCheck(this, InternalSet);
                  this._set = new Set(from);
                  this._hasRef = false;
                }
                InternalSet.prototype.add = function add(value, refs) {
                  var isRef = Ref.isRef(value);
                  if (!isRef && this.has(value, null, null, false)) {
                    return this;
                  }
                  if (refs !== void 0) {
                    Ref.push(refs, value);
                  }
                  this._set.add(value);
                  this._hasRef |= isRef;
                  return this;
                };
                InternalSet.prototype.merge = function merge(add, remove) {
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = void 0;
                  try {
                    for (var _iterator = add._set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      var item = _step.value;
                      this.add(item);
                    }
                  } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                      }
                    } finally {
                      if (_didIteratorError) {
                        throw _iteratorError;
                      }
                    }
                  }
                  var _iteratorNormalCompletion2 = true;
                  var _didIteratorError2 = false;
                  var _iteratorError2 = void 0;
                  try {
                    for (var _iterator2 = remove._set[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                      var _item = _step2.value;
                      this.remove(_item);
                    }
                  } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                      }
                    } finally {
                      if (_didIteratorError2) {
                        throw _iteratorError2;
                      }
                    }
                  }
                  return this;
                };
                InternalSet.prototype.remove = function remove(value) {
                  this._set.delete(value);
                  return this;
                };
                InternalSet.prototype.has = function has(value, state, options, insensitive) {
                  if (!this._set.size) {
                    return false;
                  }
                  var hasValue = this._set.has(value);
                  if (hasValue) {
                    return hasValue;
                  }
                  var extendedCheck = internals.extendedCheckForValue(value, insensitive);
                  if (!extendedCheck) {
                    if (state && this._hasRef) {
                      var _iteratorNormalCompletion3 = true;
                      var _didIteratorError3 = false;
                      var _iteratorError3 = void 0;
                      try {
                        for (var _iterator3 = this._set[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                          var item = _step3.value;
                          if (Ref.isRef(item)) {
                            item = item(state.reference || state.parent, options);
                            if (value === item || Array.isArray(item) && item.includes(value)) {
                              return true;
                            }
                          }
                        }
                      } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                          }
                        } finally {
                          if (_didIteratorError3) {
                            throw _iteratorError3;
                          }
                        }
                      }
                    }
                    return false;
                  }
                  return this._has(value, state, options, extendedCheck);
                };
                InternalSet.prototype._has = function _has(value, state, options, check) {
                  var checkRef = !!(state && this._hasRef);
                  var isReallyEqual = function isReallyEqual2(item2) {
                    if (value === item2) {
                      return true;
                    }
                    return check(item2);
                  };
                  var _iteratorNormalCompletion4 = true;
                  var _didIteratorError4 = false;
                  var _iteratorError4 = void 0;
                  try {
                    for (var _iterator4 = this._set[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                      var item = _step4.value;
                      if (checkRef && Ref.isRef(item)) {
                        item = item(state.reference || state.parent, options);
                        if (Array.isArray(item)) {
                          if (item.find(isReallyEqual)) {
                            return true;
                          }
                          continue;
                        }
                      }
                      if (isReallyEqual(item)) {
                        return true;
                      }
                    }
                  } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                      }
                    } finally {
                      if (_didIteratorError4) {
                        throw _iteratorError4;
                      }
                    }
                  }
                  return false;
                };
                InternalSet.prototype.values = function values(options) {
                  if (options && options.stripUndefined) {
                    var values2 = [];
                    var _iteratorNormalCompletion5 = true;
                    var _didIteratorError5 = false;
                    var _iteratorError5 = void 0;
                    try {
                      for (var _iterator5 = this._set[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                        var item = _step5.value;
                        if (item !== void 0) {
                          values2.push(item);
                        }
                      }
                    } catch (err) {
                      _didIteratorError5 = true;
                      _iteratorError5 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion5 && _iterator5.return) {
                          _iterator5.return();
                        }
                      } finally {
                        if (_didIteratorError5) {
                          throw _iteratorError5;
                        }
                      }
                    }
                    return values2;
                  }
                  return Array.from(this._set);
                };
                InternalSet.prototype.slice = function slice() {
                  var set = new InternalSet(this._set);
                  set._hasRef = this._hasRef;
                  return set;
                };
                InternalSet.prototype.concat = function concat(source) {
                  var set = new InternalSet([].concat(_toConsumableArray(this._set), _toConsumableArray(source._set)));
                  set._hasRef = !!(this._hasRef | source._hasRef);
                  return set;
                };
                return InternalSet;
              }();
            }).call(exports2, __webpack_require__(3).Buffer);
          },
          /* 10 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            function _defaults(obj, defaults) {
              var keys = Object.getOwnPropertyNames(defaults);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = Object.getOwnPropertyDescriptor(defaults, key);
                if (value && value.configurable && obj[key] === void 0) {
                  Object.defineProperty(obj, key, value);
                }
              }
              return obj;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self, call) {
              if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
            }
            var Hoek = __webpack_require__(0);
            var Any = __webpack_require__(2);
            var Cast = __webpack_require__(4);
            var Ref = __webpack_require__(1);
            var internals = {};
            internals.Alternatives = function(_Any) {
              _inherits(_class, _Any);
              function _class() {
                _classCallCheck(this, _class);
                var _this = _possibleConstructorReturn(this, _Any.call(this));
                _this._type = "alternatives";
                _this._invalids.remove(null);
                _this._inner.matches = [];
                return _this;
              }
              _class.prototype._init = function _init() {
                return arguments.length ? this.try.apply(this, arguments) : this;
              };
              _class.prototype._base = function _base(value, state, options) {
                var errors = [];
                var il = this._inner.matches.length;
                var baseType = this._baseType;
                for (var i = 0; i < il; ++i) {
                  var item = this._inner.matches[i];
                  if (!item.schema) {
                    var schema = item.peek || item.is;
                    var input = item.is ? item.ref(state.reference || state.parent, options) : value;
                    var failed = schema._validate(input, null, options, state.parent).errors;
                    if (failed) {
                      if (item.otherwise) {
                        return item.otherwise._validate(value, state, options);
                      }
                    } else if (item.then) {
                      return item.then._validate(value, state, options);
                    }
                    if (i === il - 1 && baseType) {
                      return baseType._validate(value, state, options);
                    }
                    continue;
                  }
                  var result = item.schema._validate(value, state, options);
                  if (!result.errors) {
                    return result;
                  }
                  errors = errors.concat(result.errors);
                }
                if (errors.length) {
                  return { errors: this.createError("alternatives.child", { reason: errors }, state, options) };
                }
                return { errors: this.createError("alternatives.base", null, state, options) };
              };
              _class.prototype.try = function _try() {
                for (var _len = arguments.length, schemas = Array(_len), _key = 0; _key < _len; _key++) {
                  schemas[_key] = arguments[_key];
                }
                schemas = Hoek.flatten(schemas);
                Hoek.assert(schemas.length, "Cannot add other alternatives without at least one schema");
                var obj = this.clone();
                for (var i = 0; i < schemas.length; ++i) {
                  var cast = Cast.schema(this._currentJoi, schemas[i]);
                  if (cast._refs.length) {
                    obj._refs = obj._refs.concat(cast._refs);
                  }
                  obj._inner.matches.push({ schema: cast });
                }
                return obj;
              };
              _class.prototype.when = function when(condition, options) {
                var schemaCondition = false;
                Hoek.assert(Ref.isRef(condition) || typeof condition === "string" || (schemaCondition = condition instanceof Any), "Invalid condition:", condition);
                Hoek.assert(options, "Missing options");
                Hoek.assert((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object", "Invalid options");
                if (schemaCondition) {
                  Hoek.assert(!options.hasOwnProperty("is"), '"is" can not be used with a schema condition');
                } else {
                  Hoek.assert(options.hasOwnProperty("is"), 'Missing "is" directive');
                }
                Hoek.assert(options.then !== void 0 || options.otherwise !== void 0, 'options must have at least one of "then" or "otherwise"');
                var obj = this.clone();
                var is = void 0;
                if (!schemaCondition) {
                  is = Cast.schema(this._currentJoi, options.is);
                  if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {
                    is = is.required();
                  }
                }
                var item = {
                  ref: schemaCondition ? null : Cast.ref(condition),
                  peek: schemaCondition ? condition : null,
                  is,
                  then: options.then !== void 0 ? Cast.schema(this._currentJoi, options.then) : void 0,
                  otherwise: options.otherwise !== void 0 ? Cast.schema(this._currentJoi, options.otherwise) : void 0
                };
                if (obj._baseType) {
                  item.then = item.then && obj._baseType.concat(item.then);
                  item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);
                }
                if (!schemaCondition) {
                  Ref.push(obj._refs, item.ref);
                  obj._refs = obj._refs.concat(item.is._refs);
                }
                if (item.then && item.then._refs) {
                  obj._refs = obj._refs.concat(item.then._refs);
                }
                if (item.otherwise && item.otherwise._refs) {
                  obj._refs = obj._refs.concat(item.otherwise._refs);
                }
                obj._inner.matches.push(item);
                return obj;
              };
              _class.prototype.describe = function describe() {
                var description = Any.prototype.describe.call(this);
                var alternatives = [];
                for (var i = 0; i < this._inner.matches.length; ++i) {
                  var item = this._inner.matches[i];
                  if (item.schema) {
                    alternatives.push(item.schema.describe());
                  } else {
                    var when = item.is ? {
                      ref: item.ref.toString(),
                      is: item.is.describe()
                    } : {
                      peek: item.peek.describe()
                    };
                    if (item.then) {
                      when.then = item.then.describe();
                    }
                    if (item.otherwise) {
                      when.otherwise = item.otherwise.describe();
                    }
                    alternatives.push(when);
                  }
                }
                description.alternatives = alternatives;
                return description;
              };
              return _class;
            }(Any);
            module2.exports = new internals.Alternatives();
          },
          /* 11 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var Hoek = __webpack_require__(0);
            var internals = {};
            exports2.concat = function(target, source) {
              if (!source) {
                return target;
              }
              var obj = _extends({}, target);
              var sKeys = Object.keys(source);
              for (var i = 0; i < sKeys.length; ++i) {
                var key = sKeys[i];
                if (key !== "language" || !obj.hasOwnProperty(key)) {
                  obj[key] = source[key];
                } else {
                  obj[key] = Hoek.applyToDefaults(obj[key], source[key]);
                }
              }
              return obj;
            };
          },
          /* 12 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _defaults(obj, defaults) {
              var keys = Object.getOwnPropertyNames(defaults);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = Object.getOwnPropertyDescriptor(defaults, key);
                if (value && value.configurable && obj[key] === void 0) {
                  Object.defineProperty(obj, key, value);
                }
              }
              return obj;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self, call) {
              if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
            }
            var Any = __webpack_require__(2);
            var Ref = __webpack_require__(1);
            var Hoek = __webpack_require__(0);
            var internals = {};
            internals.isoDate = /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/;
            internals.invalidDate = /* @__PURE__ */ new Date("");
            internals.isIsoDate = function() {
              var isoString = internals.isoDate.toString();
              return function(date) {
                return date && date.toString() === isoString;
              };
            }();
            internals.Date = function(_Any) {
              _inherits(_class, _Any);
              function _class() {
                _classCallCheck(this, _class);
                var _this = _possibleConstructorReturn(this, _Any.call(this));
                _this._type = "date";
                return _this;
              }
              _class.prototype._base = function _base(value, state, options) {
                var result = {
                  value: options.convert && internals.Date.toDate(value, this._flags.format, this._flags.timestamp, this._flags.multiplier) || value
                };
                if (result.value instanceof Date && !isNaN(result.value.getTime())) {
                  result.errors = null;
                } else if (!options.convert) {
                  result.errors = this.createError("date.strict", null, state, options);
                } else {
                  var type = void 0;
                  if (internals.isIsoDate(this._flags.format)) {
                    type = "isoDate";
                  } else if (this._flags.timestamp) {
                    type = "timestamp." + this._flags.timestamp;
                  } else {
                    type = "base";
                  }
                  result.errors = this.createError("date." + type, null, state, options);
                }
                return result;
              };
              _class.toDate = function toDate(value, format, timestamp, multiplier) {
                if (value instanceof Date) {
                  return value;
                }
                if (typeof value === "string" || typeof value === "number" && !isNaN(value) && isFinite(value)) {
                  if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
                    value = parseFloat(value);
                  }
                  var date = void 0;
                  if (format && internals.isIsoDate(format)) {
                    date = format.test(value) ? new Date(value) : internals.invalidDate;
                  } else if (timestamp && multiplier) {
                    date = /^\s*$/.test(value) ? internals.invalidDate : new Date(value * multiplier);
                  } else {
                    date = new Date(value);
                  }
                  if (!isNaN(date.getTime())) {
                    return date;
                  }
                }
                return null;
              };
              _class.prototype.iso = function iso() {
                if (this._flags.format === internals.isoDate) {
                  return this;
                }
                var obj = this.clone();
                obj._flags.format = internals.isoDate;
                return obj;
              };
              _class.prototype.timestamp = function timestamp() {
                var type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "javascript";
                var allowed = ["javascript", "unix"];
                Hoek.assert(allowed.includes(type), '"type" must be one of "' + allowed.join('", "') + '"');
                if (this._flags.timestamp === type) {
                  return this;
                }
                var obj = this.clone();
                obj._flags.timestamp = type;
                obj._flags.multiplier = type === "unix" ? 1e3 : 1;
                return obj;
              };
              _class.prototype._isIsoDate = function _isIsoDate(value) {
                return internals.isoDate.test(value);
              };
              return _class;
            }(Any);
            internals.compare = function(type, compare) {
              return function(date) {
                var isNow = date === "now";
                var isRef = Ref.isRef(date);
                if (!isNow && !isRef) {
                  date = internals.Date.toDate(date);
                }
                Hoek.assert(date, "Invalid date format");
                return this._test(type, date, function(value, state, options) {
                  var compareTo = void 0;
                  if (isNow) {
                    compareTo = Date.now();
                  } else if (isRef) {
                    compareTo = internals.Date.toDate(date(state.reference || state.parent, options));
                    if (!compareTo) {
                      return this.createError("date.ref", { ref: date.key }, state, options);
                    }
                    compareTo = compareTo.getTime();
                  } else {
                    compareTo = date.getTime();
                  }
                  if (compare(value.getTime(), compareTo)) {
                    return value;
                  }
                  return this.createError("date." + type, { limit: new Date(compareTo) }, state, options);
                });
              };
            };
            internals.Date.prototype.min = internals.compare("min", function(value, date) {
              return value >= date;
            });
            internals.Date.prototype.max = internals.compare("max", function(value, date) {
              return value <= date;
            });
            internals.Date.prototype.greater = internals.compare("greater", function(value, date) {
              return value > date;
            });
            internals.Date.prototype.less = internals.compare("less", function(value, date) {
              return value < date;
            });
            module2.exports = new internals.Date();
          },
          /* 13 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            function _defaults(obj, defaults) {
              var keys = Object.getOwnPropertyNames(defaults);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = Object.getOwnPropertyDescriptor(defaults, key);
                if (value && value.configurable && obj[key] === void 0) {
                  Object.defineProperty(obj, key, value);
                }
              }
              return obj;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self, call) {
              if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
            }
            var Hoek = __webpack_require__(0);
            var Topo = __webpack_require__(31);
            var Any = __webpack_require__(2);
            var Errors = __webpack_require__(6);
            var Cast = __webpack_require__(4);
            var internals = {};
            internals.Object = function(_Any) {
              _inherits(_class, _Any);
              function _class() {
                _classCallCheck(this, _class);
                var _this = _possibleConstructorReturn(this, _Any.call(this));
                _this._type = "object";
                _this._inner.children = null;
                _this._inner.renames = [];
                _this._inner.dependencies = [];
                _this._inner.patterns = [];
                return _this;
              }
              _class.prototype._init = function _init() {
                return arguments.length ? this.keys.apply(this, arguments) : this;
              };
              _class.prototype._base = function _base(value, state, options) {
                var target = value;
                var errors = [];
                var finish = function finish2() {
                  return {
                    value: target,
                    errors: errors.length ? errors : null
                  };
                };
                if (typeof value === "string" && options.convert) {
                  value = internals.safeParse(value);
                }
                var type = this._flags.func ? "function" : "object";
                if (!value || (typeof value === "undefined" ? "undefined" : _typeof(value)) !== type || Array.isArray(value)) {
                  errors.push(this.createError(type + ".base", null, state, options));
                  return finish();
                }
                if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && // null allows any keys
                !this._inner.patterns.length) {
                  target = value;
                  return finish();
                }
                if (target === value) {
                  if (type === "object") {
                    target = Object.create(Object.getPrototypeOf(value));
                  } else {
                    target = function target2() {
                      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                      }
                      return value.apply(this, args);
                    };
                    target.prototype = Hoek.clone(value.prototype);
                  }
                  var valueKeys = Object.keys(value);
                  for (var i = 0; i < valueKeys.length; ++i) {
                    target[valueKeys[i]] = value[valueKeys[i]];
                  }
                } else {
                  target = value;
                }
                var renamed = {};
                for (var _i = 0; _i < this._inner.renames.length; ++_i) {
                  var rename = this._inner.renames[_i];
                  if (rename.isRegExp) {
                    var targetKeys = Object.keys(target);
                    var matchedTargetKeys = [];
                    for (var j = 0; j < targetKeys.length; ++j) {
                      if (rename.from.test(targetKeys[j])) {
                        matchedTargetKeys.push(targetKeys[j]);
                      }
                    }
                    var allUndefined = matchedTargetKeys.every(function(key2) {
                      return target[key2] === void 0;
                    });
                    if (rename.options.ignoreUndefined && allUndefined) {
                      continue;
                    }
                    if (!rename.options.multiple && renamed[rename.to]) {
                      errors.push(this.createError("object.rename.regex.multiple", { from: matchedTargetKeys, to: rename.to }, state, options));
                      if (options.abortEarly) {
                        return finish();
                      }
                    }
                    if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {
                      errors.push(this.createError("object.rename.regex.override", { from: matchedTargetKeys, to: rename.to }, state, options));
                      if (options.abortEarly) {
                        return finish();
                      }
                    }
                    if (allUndefined) {
                      delete target[rename.to];
                    } else {
                      target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];
                    }
                    renamed[rename.to] = true;
                    if (!rename.options.alias) {
                      for (var _j = 0; _j < matchedTargetKeys.length; ++_j) {
                        delete target[matchedTargetKeys[_j]];
                      }
                    }
                  } else {
                    if (rename.options.ignoreUndefined && target[rename.from] === void 0) {
                      continue;
                    }
                    if (!rename.options.multiple && renamed[rename.to]) {
                      errors.push(this.createError("object.rename.multiple", { from: rename.from, to: rename.to }, state, options));
                      if (options.abortEarly) {
                        return finish();
                      }
                    }
                    if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {
                      errors.push(this.createError("object.rename.override", { from: rename.from, to: rename.to }, state, options));
                      if (options.abortEarly) {
                        return finish();
                      }
                    }
                    if (target[rename.from] === void 0) {
                      delete target[rename.to];
                    } else {
                      target[rename.to] = target[rename.from];
                    }
                    renamed[rename.to] = true;
                    if (!rename.options.alias) {
                      delete target[rename.from];
                    }
                  }
                }
                if (!this._inner.children && // null allows any keys
                !this._inner.patterns.length && !this._inner.dependencies.length) {
                  return finish();
                }
                var unprocessed = new Set(Object.keys(target));
                if (this._inner.children) {
                  var stripProps = [];
                  for (var _i2 = 0; _i2 < this._inner.children.length; ++_i2) {
                    var child = this._inner.children[_i2];
                    var key = child.key;
                    var item = target[key];
                    unprocessed.delete(key);
                    var localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };
                    var result = child.schema._validate(item, localState, options);
                    if (result.errors) {
                      errors.push(this.createError("object.child", { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));
                      if (options.abortEarly) {
                        return finish();
                      }
                    } else {
                      if (child.schema._flags.strip || result.value === void 0 && result.value !== item) {
                        stripProps.push(key);
                        target[key] = result.finalValue;
                      } else if (result.value !== void 0) {
                        target[key] = result.value;
                      }
                    }
                  }
                  for (var _i3 = 0; _i3 < stripProps.length; ++_i3) {
                    delete target[stripProps[_i3]];
                  }
                }
                if (unprocessed.size && this._inner.patterns.length) {
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = void 0;
                  try {
                    for (var _iterator = unprocessed[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                      var _key2 = _step.value;
                      var _localState = {
                        key: _key2,
                        path: state.path.concat(_key2),
                        parent: target,
                        reference: state.reference
                      };
                      var _item = target[_key2];
                      for (var _i4 = 0; _i4 < this._inner.patterns.length; ++_i4) {
                        var pattern = this._inner.patterns[_i4];
                        if (pattern.regex ? pattern.regex.test(_key2) : !pattern.schema.validate(_key2).error) {
                          unprocessed.delete(_key2);
                          var _result = pattern.rule._validate(_item, _localState, options);
                          if (_result.errors) {
                            errors.push(this.createError("object.child", {
                              key: _key2,
                              child: pattern.rule._getLabel(_key2),
                              reason: _result.errors
                            }, _localState, options));
                            if (options.abortEarly) {
                              return finish();
                            }
                          }
                          target[_key2] = _result.value;
                        }
                      }
                    }
                  } catch (err2) {
                    _didIteratorError = true;
                    _iteratorError = err2;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                      }
                    } finally {
                      if (_didIteratorError) {
                        throw _iteratorError;
                      }
                    }
                  }
                }
                if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {
                  if (options.stripUnknown && this._flags.allowUnknown !== true || options.skipFunctions) {
                    var stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.objects : false;
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = void 0;
                    try {
                      for (var _iterator2 = unprocessed[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var _key3 = _step2.value;
                        if (stripUnknown) {
                          delete target[_key3];
                          unprocessed.delete(_key3);
                        } else if (typeof target[_key3] === "function") {
                          unprocessed.delete(_key3);
                        }
                      }
                    } catch (err2) {
                      _didIteratorError2 = true;
                      _iteratorError2 = err2;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                          _iterator2.return();
                        }
                      } finally {
                        if (_didIteratorError2) {
                          throw _iteratorError2;
                        }
                      }
                    }
                  }
                  if (this._flags.allowUnknown !== void 0 ? !this._flags.allowUnknown : !options.allowUnknown) {
                    var _iteratorNormalCompletion3 = true;
                    var _didIteratorError3 = false;
                    var _iteratorError3 = void 0;
                    try {
                      for (var _iterator3 = unprocessed[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var unprocessedKey = _step3.value;
                        errors.push(this.createError("object.allowUnknown", { child: unprocessedKey }, {
                          key: unprocessedKey,
                          path: state.path.concat(unprocessedKey)
                        }, options, {}));
                      }
                    } catch (err2) {
                      _didIteratorError3 = true;
                      _iteratorError3 = err2;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                          _iterator3.return();
                        }
                      } finally {
                        if (_didIteratorError3) {
                          throw _iteratorError3;
                        }
                      }
                    }
                  }
                }
                for (var _i5 = 0; _i5 < this._inner.dependencies.length; ++_i5) {
                  var dep = this._inner.dependencies[_i5];
                  var err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);
                  if (err instanceof Errors.Err) {
                    errors.push(err);
                    if (options.abortEarly) {
                      return finish();
                    }
                  }
                }
                return finish();
              };
              _class.prototype.keys = function keys(schema) {
                Hoek.assert(schema === null || schema === void 0 || (typeof schema === "undefined" ? "undefined" : _typeof(schema)) === "object", "Object schema must be a valid object");
                Hoek.assert(!schema || !(schema instanceof Any), "Object schema cannot be a joi schema");
                var obj = this.clone();
                if (!schema) {
                  obj._inner.children = null;
                  return obj;
                }
                var children = Object.keys(schema);
                if (!children.length) {
                  obj._inner.children = [];
                  return obj;
                }
                var topo = new Topo();
                if (obj._inner.children) {
                  for (var i = 0; i < obj._inner.children.length; ++i) {
                    var child = obj._inner.children[i];
                    if (!children.includes(child.key)) {
                      topo.add(child, { after: child._refs, group: child.key });
                    }
                  }
                }
                for (var _i6 = 0; _i6 < children.length; ++_i6) {
                  var key = children[_i6];
                  var _child = schema[key];
                  try {
                    var cast = Cast.schema(this._currentJoi, _child);
                    topo.add({ key, schema: cast }, { after: cast._refs, group: key });
                  } catch (castErr) {
                    if (castErr.hasOwnProperty("path")) {
                      castErr.path = key + "." + castErr.path;
                    } else {
                      castErr.path = key;
                    }
                    throw castErr;
                  }
                }
                obj._inner.children = topo.nodes;
                return obj;
              };
              _class.prototype.append = function append(schema) {
                if (schema === null || schema === void 0 || Object.keys(schema).length === 0) {
                  return this;
                }
                return this.keys(schema);
              };
              _class.prototype.unknown = function unknown(allow) {
                var value = allow !== false;
                if (this._flags.allowUnknown === value) {
                  return this;
                }
                var obj = this.clone();
                obj._flags.allowUnknown = value;
                return obj;
              };
              _class.prototype.length = function length(limit) {
                Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, "limit must be a positive integer");
                return this._test("length", limit, function(value, state, options) {
                  if (Object.keys(value).length === limit) {
                    return value;
                  }
                  return this.createError("object.length", { limit }, state, options);
                });
              };
              _class.prototype.min = function min(limit) {
                Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, "limit must be a positive integer");
                return this._test("min", limit, function(value, state, options) {
                  if (Object.keys(value).length >= limit) {
                    return value;
                  }
                  return this.createError("object.min", { limit }, state, options);
                });
              };
              _class.prototype.max = function max(limit) {
                Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, "limit must be a positive integer");
                return this._test("max", limit, function(value, state, options) {
                  if (Object.keys(value).length <= limit) {
                    return value;
                  }
                  return this.createError("object.max", { limit }, state, options);
                });
              };
              _class.prototype.pattern = function pattern(_pattern, schema) {
                var isRegExp = _pattern instanceof RegExp;
                Hoek.assert(isRegExp || _pattern instanceof Any, "pattern must be a regex or schema");
                Hoek.assert(schema !== void 0, "Invalid rule");
                if (isRegExp) {
                  _pattern = new RegExp(_pattern.source, _pattern.ignoreCase ? "i" : void 0);
                }
                try {
                  schema = Cast.schema(this._currentJoi, schema);
                } catch (castErr) {
                  if (castErr.hasOwnProperty("path")) {
                    castErr.message = castErr.message + "(" + castErr.path + ")";
                  }
                  throw castErr;
                }
                var obj = this.clone();
                if (isRegExp) {
                  obj._inner.patterns.push({ regex: _pattern, rule: schema });
                } else {
                  obj._inner.patterns.push({ schema: _pattern, rule: schema });
                }
                return obj;
              };
              _class.prototype.schema = function schema() {
                return this._test("schema", null, function(value, state, options) {
                  if (value instanceof Any) {
                    return value;
                  }
                  return this.createError("object.schema", null, state, options);
                });
              };
              _class.prototype.with = function _with(key, peers) {
                Hoek.assert(arguments.length === 2, "Invalid number of arguments, expected 2.");
                return this._dependency("with", key, peers);
              };
              _class.prototype.without = function without(key, peers) {
                Hoek.assert(arguments.length === 2, "Invalid number of arguments, expected 2.");
                return this._dependency("without", key, peers);
              };
              _class.prototype.xor = function xor() {
                for (var _len2 = arguments.length, peers = Array(_len2), _key4 = 0; _key4 < _len2; _key4++) {
                  peers[_key4] = arguments[_key4];
                }
                peers = Hoek.flatten(peers);
                return this._dependency("xor", null, peers);
              };
              _class.prototype.or = function or() {
                for (var _len3 = arguments.length, peers = Array(_len3), _key5 = 0; _key5 < _len3; _key5++) {
                  peers[_key5] = arguments[_key5];
                }
                peers = Hoek.flatten(peers);
                return this._dependency("or", null, peers);
              };
              _class.prototype.and = function and() {
                for (var _len4 = arguments.length, peers = Array(_len4), _key6 = 0; _key6 < _len4; _key6++) {
                  peers[_key6] = arguments[_key6];
                }
                peers = Hoek.flatten(peers);
                return this._dependency("and", null, peers);
              };
              _class.prototype.nand = function nand() {
                for (var _len5 = arguments.length, peers = Array(_len5), _key7 = 0; _key7 < _len5; _key7++) {
                  peers[_key7] = arguments[_key7];
                }
                peers = Hoek.flatten(peers);
                return this._dependency("nand", null, peers);
              };
              _class.prototype.requiredKeys = function requiredKeys() {
                for (var _len6 = arguments.length, children = Array(_len6), _key8 = 0; _key8 < _len6; _key8++) {
                  children[_key8] = arguments[_key8];
                }
                children = Hoek.flatten(children);
                return this.applyFunctionToChildren(children, "required");
              };
              _class.prototype.optionalKeys = function optionalKeys() {
                for (var _len7 = arguments.length, children = Array(_len7), _key9 = 0; _key9 < _len7; _key9++) {
                  children[_key9] = arguments[_key9];
                }
                children = Hoek.flatten(children);
                return this.applyFunctionToChildren(children, "optional");
              };
              _class.prototype.forbiddenKeys = function forbiddenKeys() {
                for (var _len8 = arguments.length, children = Array(_len8), _key10 = 0; _key10 < _len8; _key10++) {
                  children[_key10] = arguments[_key10];
                }
                children = Hoek.flatten(children);
                return this.applyFunctionToChildren(children, "forbidden");
              };
              _class.prototype.rename = function rename(from, to, options) {
                Hoek.assert(typeof from === "string" || from instanceof RegExp, "Rename missing the from argument");
                Hoek.assert(typeof to === "string", "Rename missing the to argument");
                Hoek.assert(to !== from, "Cannot rename key to same name:", from);
                for (var i = 0; i < this._inner.renames.length; ++i) {
                  Hoek.assert(this._inner.renames[i].from !== from, "Cannot rename the same key multiple times");
                }
                var obj = this.clone();
                obj._inner.renames.push({
                  from,
                  to,
                  options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),
                  isRegExp: from instanceof RegExp
                });
                return obj;
              };
              _class.prototype.applyFunctionToChildren = function applyFunctionToChildren(children, fn, args, root) {
                children = [].concat(children);
                Hoek.assert(children.length > 0, "expected at least one children");
                var groupedChildren = internals.groupChildren(children);
                var obj = void 0;
                if ("" in groupedChildren) {
                  obj = this[fn].apply(this, args);
                  delete groupedChildren[""];
                } else {
                  obj = this.clone();
                }
                if (obj._inner.children) {
                  root = root ? root + "." : "";
                  for (var i = 0; i < obj._inner.children.length; ++i) {
                    var child = obj._inner.children[i];
                    var group = groupedChildren[child.key];
                    if (group) {
                      obj._inner.children[i] = {
                        key: child.key,
                        _refs: child._refs,
                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)
                      };
                      delete groupedChildren[child.key];
                    }
                  }
                }
                var remaining = Object.keys(groupedChildren);
                Hoek.assert(remaining.length === 0, "unknown key(s)", remaining.join(", "));
                return obj;
              };
              _class.prototype._dependency = function _dependency(type, key, peers) {
                peers = [].concat(peers);
                for (var i = 0; i < peers.length; ++i) {
                  Hoek.assert(typeof peers[i] === "string", type, "peers must be a string or array of strings");
                }
                var obj = this.clone();
                obj._inner.dependencies.push({ type, key, peers });
                return obj;
              };
              _class.prototype.describe = function describe(shallow) {
                var description = Any.prototype.describe.call(this);
                if (description.rules) {
                  for (var i = 0; i < description.rules.length; ++i) {
                    var rule = description.rules[i];
                    if (
                      /* $lab:coverage:off$ */
                      rule.arg && _typeof(rule.arg) === "object" && rule.arg.schema && rule.arg.ref
                    ) {
                      rule.arg = {
                        schema: rule.arg.schema.describe(),
                        ref: rule.arg.ref.toString()
                      };
                    }
                  }
                }
                if (this._inner.children && !shallow) {
                  description.children = {};
                  for (var _i7 = 0; _i7 < this._inner.children.length; ++_i7) {
                    var child = this._inner.children[_i7];
                    description.children[child.key] = child.schema.describe();
                  }
                }
                if (this._inner.dependencies.length) {
                  description.dependencies = Hoek.clone(this._inner.dependencies);
                }
                if (this._inner.patterns.length) {
                  description.patterns = [];
                  for (var _i8 = 0; _i8 < this._inner.patterns.length; ++_i8) {
                    var pattern = this._inner.patterns[_i8];
                    if (pattern.regex) {
                      description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });
                    } else {
                      description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });
                    }
                  }
                }
                if (this._inner.renames.length > 0) {
                  description.renames = Hoek.clone(this._inner.renames);
                }
                return description;
              };
              _class.prototype.assert = function assert(ref, schema, message) {
                ref = Cast.ref(ref);
                Hoek.assert(ref.isContext || ref.depth > 1, "Cannot use assertions for root level references - use direct key rules instead");
                message = message || "pass the assertion test";
                try {
                  schema = Cast.schema(this._currentJoi, schema);
                } catch (castErr) {
                  if (castErr.hasOwnProperty("path")) {
                    castErr.message = castErr.message + "(" + castErr.path + ")";
                  }
                  throw castErr;
                }
                var key = ref.path[ref.path.length - 1];
                var path = ref.path.join(".");
                return this._test("assert", { schema, ref }, function(value, state, options) {
                  var result = schema._validate(ref(value), null, options, value);
                  if (!result.errors) {
                    return value;
                  }
                  var localState = Hoek.merge({}, state);
                  localState.key = key;
                  localState.path = ref.path;
                  return this.createError("object.assert", { ref: path, message }, localState, options);
                });
              };
              _class.prototype.type = function type(constructor) {
                var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : constructor.name;
                Hoek.assert(typeof constructor === "function", "type must be a constructor function");
                var typeData = {
                  name,
                  ctor: constructor
                };
                return this._test("type", typeData, function(value, state, options) {
                  if (value instanceof constructor) {
                    return value;
                  }
                  return this.createError("object.type", { type: typeData.name }, state, options);
                });
              };
              return _class;
            }(Any);
            internals.safeParse = function(value) {
              try {
                return JSON.parse(value);
              } catch (parseErr) {
              }
              return value;
            };
            internals.renameDefaults = {
              alias: false,
              // Keep old value in place
              multiple: false,
              // Allow renaming multiple keys into the same target
              override: false
              // Overrides an existing key
            };
            internals.groupChildren = function(children) {
              children.sort();
              var grouped = {};
              for (var i = 0; i < children.length; ++i) {
                var child = children[i];
                Hoek.assert(typeof child === "string", "children must be strings");
                var group = child.split(".")[0];
                var childGroup = grouped[group] = grouped[group] || [];
                childGroup.push(child.substring(group.length + 1));
              }
              return grouped;
            };
            internals.keysToLabels = function(schema, keys) {
              var children = schema._inner.children;
              if (!children) {
                return keys;
              }
              var findLabel = function findLabel2(key) {
                var matchingChild = children.find(function(child) {
                  return child.key === key;
                });
                return matchingChild ? matchingChild.schema._getLabel(key) : key;
              };
              if (Array.isArray(keys)) {
                return keys.map(findLabel);
              }
              return findLabel(keys);
            };
            internals.with = function(value, peers, parent, state, options) {
              if (value === void 0) {
                return value;
              }
              for (var i = 0; i < peers.length; ++i) {
                var peer = peers[i];
                if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === void 0) {
                  return this.createError("object.with", {
                    main: state.key,
                    mainWithLabel: internals.keysToLabels(this, state.key),
                    peer,
                    peerWithLabel: internals.keysToLabels(this, peer)
                  }, state, options);
                }
              }
              return value;
            };
            internals.without = function(value, peers, parent, state, options) {
              if (value === void 0) {
                return value;
              }
              for (var i = 0; i < peers.length; ++i) {
                var peer = peers[i];
                if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== void 0) {
                  return this.createError("object.without", {
                    main: state.key,
                    mainWithLabel: internals.keysToLabels(this, state.key),
                    peer,
                    peerWithLabel: internals.keysToLabels(this, peer)
                  }, state, options);
                }
              }
              return value;
            };
            internals.xor = function(value, peers, parent, state, options) {
              var present = [];
              for (var i = 0; i < peers.length; ++i) {
                var peer = peers[i];
                if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== void 0) {
                  present.push(peer);
                }
              }
              if (present.length === 1) {
                return value;
              }
              var context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };
              if (present.length === 0) {
                return this.createError("object.missing", context, state, options);
              }
              return this.createError("object.xor", context, state, options);
            };
            internals.or = function(value, peers, parent, state, options) {
              for (var i = 0; i < peers.length; ++i) {
                var peer = peers[i];
                if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== void 0) {
                  return value;
                }
              }
              return this.createError("object.missing", {
                peers,
                peersWithLabels: internals.keysToLabels(this, peers)
              }, state, options);
            };
            internals.and = function(value, peers, parent, state, options) {
              var missing = [];
              var present = [];
              var count = peers.length;
              for (var i = 0; i < count; ++i) {
                var peer = peers[i];
                if (!Object.prototype.hasOwnProperty.call(parent, peer) || parent[peer] === void 0) {
                  missing.push(peer);
                } else {
                  present.push(peer);
                }
              }
              var aon = missing.length === count || present.length === count;
              if (!aon) {
                return this.createError("object.and", {
                  present,
                  presentWithLabels: internals.keysToLabels(this, present),
                  missing,
                  missingWithLabels: internals.keysToLabels(this, missing)
                }, state, options);
              }
            };
            internals.nand = function(value, peers, parent, state, options) {
              var present = [];
              for (var i = 0; i < peers.length; ++i) {
                var peer = peers[i];
                if (Object.prototype.hasOwnProperty.call(parent, peer) && parent[peer] !== void 0) {
                  present.push(peer);
                }
              }
              var values = Hoek.clone(peers);
              var main = values.splice(0, 1)[0];
              var allPresent = present.length === peers.length;
              return allPresent ? this.createError("object.nand", {
                main,
                mainWithLabel: internals.keysToLabels(this, main),
                peers: values,
                peersWithLabels: internals.keysToLabels(this, values)
              }, state, options) : null;
            };
            module2.exports = new internals.Object();
          },
          /* 14 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var internals = {
              rfc3986: {}
            };
            internals.generate = function() {
              var or = "|";
              var zeroPad = "0?";
              var digit = "0-9";
              var digitOnly = "[" + digit + "]";
              var alpha = "a-zA-Z";
              var alphaOnly = "[" + alpha + "]";
              internals.rfc3986.ipv4Cidr = digitOnly + or + "[1-2]" + digitOnly + or + "3[0-2]";
              internals.rfc3986.ipv6Cidr = "(?:" + zeroPad + zeroPad + digitOnly + or + zeroPad + "[1-9]" + digitOnly + or + "1[01]" + digitOnly + or + "12[0-8])";
              var hexDigit = digit + "A-Fa-f";
              var hexDigitOnly = "[" + hexDigit + "]";
              var unreserved = alpha + digit + "-\\._~";
              var subDelims = "!\\$&'\\(\\)\\*\\+,;=";
              var pctEncoded = "%" + hexDigit;
              var pchar = unreserved + pctEncoded + subDelims + ":@";
              var pcharOnly = "[" + pchar + "]";
              var decOctect = "(?:" + zeroPad + zeroPad + digitOnly + or + zeroPad + "[1-9]" + digitOnly + or + "1" + digitOnly + digitOnly + or + "2[0-4]" + digitOnly + or + "25[0-5])";
              internals.rfc3986.IPv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
              var h16 = hexDigitOnly + "{1,4}";
              var ls32 = "(?:" + h16 + ":" + h16 + "|" + internals.rfc3986.IPv4address + ")";
              var IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
              var IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
              var IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
              var IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
              var IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
              var IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
              var IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
              var IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
              var IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
              internals.rfc3986.IPv6address = "(?:" + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ")";
              internals.rfc3986.IPvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
              internals.rfc3986.scheme = alphaOnly + "[" + alpha + digit + "+-\\.]*";
              var userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
              var IPLiteral = "\\[(?:" + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ")\\]";
              var regName = "[" + unreserved + pctEncoded + subDelims + "]{0,255}";
              var host = "(?:" + IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ")";
              var port = digitOnly + "*";
              var authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
              var segment = pcharOnly + "*";
              var segmentNz = pcharOnly + "+";
              var segmentNzNc = "[" + unreserved + pctEncoded + subDelims + "@]+";
              var pathEmpty = "";
              var pathAbEmpty = "(?:\\/" + segment + ")*";
              var pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
              var pathRootless = segmentNz + pathAbEmpty;
              var pathNoScheme = segmentNzNc + pathAbEmpty;
              internals.rfc3986.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")" + or + pathAbsolute + or + pathRootless + ")";
              internals.rfc3986.relativeRef = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")" + or + pathAbsolute + or + pathNoScheme + or + pathEmpty + ")";
              internals.rfc3986.query = "[" + pchar + "\\/\\?]*(?=#|$)";
              internals.rfc3986.fragment = "[" + pchar + "\\/\\?]*";
            };
            internals.generate();
            module2.exports = internals.rfc3986;
          },
          /* 15 */
          /***/
          function(module2, exports2) {
          },
          /* 16 */
          /***/
          function(module2, exports2, __webpack_require__) {
            (function(global, process) {
              var formatRegExp = /%[sdj%]/g;
              exports2.format = function(f) {
                if (!isString(f)) {
                  var objects = [];
                  for (var i = 0; i < arguments.length; i++) {
                    objects.push(inspect(arguments[i]));
                  }
                  return objects.join(" ");
                }
                var i = 1;
                var args = arguments;
                var len = args.length;
                var str = String(f).replace(formatRegExp, function(x2) {
                  if (x2 === "%%")
                    return "%";
                  if (i >= len)
                    return x2;
                  switch (x2) {
                    case "%s":
                      return String(args[i++]);
                    case "%d":
                      return Number(args[i++]);
                    case "%j":
                      try {
                        return JSON.stringify(args[i++]);
                      } catch (_) {
                        return "[Circular]";
                      }
                    default:
                      return x2;
                  }
                });
                for (var x = args[i]; i < len; x = args[++i]) {
                  if (isNull(x) || !isObject(x)) {
                    str += " " + x;
                  } else {
                    str += " " + inspect(x);
                  }
                }
                return str;
              };
              exports2.deprecate = function(fn, msg) {
                if (isUndefined(global.process)) {
                  return function() {
                    return exports2.deprecate(fn, msg).apply(this, arguments);
                  };
                }
                if (process.noDeprecation === true) {
                  return fn;
                }
                var warned = false;
                function deprecated() {
                  if (!warned) {
                    if (process.throwDeprecation) {
                      throw new Error(msg);
                    } else if (process.traceDeprecation) {
                      console.trace(msg);
                    } else {
                      console.error(msg);
                    }
                    warned = true;
                  }
                  return fn.apply(this, arguments);
                }
                return deprecated;
              };
              var debugs = {};
              var debugEnviron;
              exports2.debuglog = function(set) {
                if (isUndefined(debugEnviron))
                  debugEnviron = process.env.NODE_DEBUG || "";
                set = set.toUpperCase();
                if (!debugs[set]) {
                  if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                      var msg = exports2.format.apply(exports2, arguments);
                      console.error("%s %d: %s", set, pid, msg);
                    };
                  } else {
                    debugs[set] = function() {
                    };
                  }
                }
                return debugs[set];
              };
              function inspect(obj, opts) {
                var ctx = {
                  seen: [],
                  stylize: stylizeNoColor
                };
                if (arguments.length >= 3)
                  ctx.depth = arguments[2];
                if (arguments.length >= 4)
                  ctx.colors = arguments[3];
                if (isBoolean(opts)) {
                  ctx.showHidden = opts;
                } else if (opts) {
                  exports2._extend(ctx, opts);
                }
                if (isUndefined(ctx.showHidden))
                  ctx.showHidden = false;
                if (isUndefined(ctx.depth))
                  ctx.depth = 2;
                if (isUndefined(ctx.colors))
                  ctx.colors = false;
                if (isUndefined(ctx.customInspect))
                  ctx.customInspect = true;
                if (ctx.colors)
                  ctx.stylize = stylizeWithColor;
                return formatValue(ctx, obj, ctx.depth);
              }
              exports2.inspect = inspect;
              inspect.colors = {
                "bold": [1, 22],
                "italic": [3, 23],
                "underline": [4, 24],
                "inverse": [7, 27],
                "white": [37, 39],
                "grey": [90, 39],
                "black": [30, 39],
                "blue": [34, 39],
                "cyan": [36, 39],
                "green": [32, 39],
                "magenta": [35, 39],
                "red": [31, 39],
                "yellow": [33, 39]
              };
              inspect.styles = {
                "special": "cyan",
                "number": "yellow",
                "boolean": "yellow",
                "undefined": "grey",
                "null": "bold",
                "string": "green",
                "date": "magenta",
                // "name": intentionally not styling
                "regexp": "red"
              };
              function stylizeWithColor(str, styleType) {
                var style = inspect.styles[styleType];
                if (style) {
                  return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
                } else {
                  return str;
                }
              }
              function stylizeNoColor(str, styleType) {
                return str;
              }
              function arrayToHash(array) {
                var hash = {};
                array.forEach(function(val, idx) {
                  hash[val] = true;
                });
                return hash;
              }
              function formatValue(ctx, value, recurseTimes) {
                if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
                !(value.constructor && value.constructor.prototype === value)) {
                  var ret = value.inspect(recurseTimes, ctx);
                  if (!isString(ret)) {
                    ret = formatValue(ctx, ret, recurseTimes);
                  }
                  return ret;
                }
                var primitive = formatPrimitive(ctx, value);
                if (primitive) {
                  return primitive;
                }
                var keys = Object.keys(value);
                var visibleKeys = arrayToHash(keys);
                if (ctx.showHidden) {
                  keys = Object.getOwnPropertyNames(value);
                }
                if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                  return formatError(value);
                }
                if (keys.length === 0) {
                  if (isFunction(value)) {
                    var name = value.name ? ": " + value.name : "";
                    return ctx.stylize("[Function" + name + "]", "special");
                  }
                  if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                  }
                  if (isDate(value)) {
                    return ctx.stylize(Date.prototype.toString.call(value), "date");
                  }
                  if (isError(value)) {
                    return formatError(value);
                  }
                }
                var base = "", array = false, braces = ["{", "}"];
                if (isArray(value)) {
                  array = true;
                  braces = ["[", "]"];
                }
                if (isFunction(value)) {
                  var n = value.name ? ": " + value.name : "";
                  base = " [Function" + n + "]";
                }
                if (isRegExp(value)) {
                  base = " " + RegExp.prototype.toString.call(value);
                }
                if (isDate(value)) {
                  base = " " + Date.prototype.toUTCString.call(value);
                }
                if (isError(value)) {
                  base = " " + formatError(value);
                }
                if (keys.length === 0 && (!array || value.length == 0)) {
                  return braces[0] + base + braces[1];
                }
                if (recurseTimes < 0) {
                  if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                  } else {
                    return ctx.stylize("[Object]", "special");
                  }
                }
                ctx.seen.push(value);
                var output;
                if (array) {
                  output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                } else {
                  output = keys.map(function(key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                  });
                }
                ctx.seen.pop();
                return reduceToSingleString(output, base, braces);
              }
              function formatPrimitive(ctx, value) {
                if (isUndefined(value))
                  return ctx.stylize("undefined", "undefined");
                if (isString(value)) {
                  var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                  return ctx.stylize(simple, "string");
                }
                if (isNumber(value))
                  return ctx.stylize("" + value, "number");
                if (isBoolean(value))
                  return ctx.stylize("" + value, "boolean");
                if (isNull(value))
                  return ctx.stylize("null", "null");
              }
              function formatError(value) {
                return "[" + Error.prototype.toString.call(value) + "]";
              }
              function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                var output = [];
                for (var i = 0, l = value.length; i < l; ++i) {
                  if (hasOwnProperty(value, String(i))) {
                    output.push(formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      String(i),
                      true
                    ));
                  } else {
                    output.push("");
                  }
                }
                keys.forEach(function(key) {
                  if (!key.match(/^\d+$/)) {
                    output.push(formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      key,
                      true
                    ));
                  }
                });
                return output;
              }
              function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                var name, str, desc;
                desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
                if (desc.get) {
                  if (desc.set) {
                    str = ctx.stylize("[Getter/Setter]", "special");
                  } else {
                    str = ctx.stylize("[Getter]", "special");
                  }
                } else {
                  if (desc.set) {
                    str = ctx.stylize("[Setter]", "special");
                  }
                }
                if (!hasOwnProperty(visibleKeys, key)) {
                  name = "[" + key + "]";
                }
                if (!str) {
                  if (ctx.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) {
                      str = formatValue(ctx, desc.value, null);
                    } else {
                      str = formatValue(ctx, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf("\n") > -1) {
                      if (array) {
                        str = str.split("\n").map(function(line) {
                          return "  " + line;
                        }).join("\n").substr(2);
                      } else {
                        str = "\n" + str.split("\n").map(function(line) {
                          return "   " + line;
                        }).join("\n");
                      }
                    }
                  } else {
                    str = ctx.stylize("[Circular]", "special");
                  }
                }
                if (isUndefined(name)) {
                  if (array && key.match(/^\d+$/)) {
                    return str;
                  }
                  name = JSON.stringify("" + key);
                  if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.substr(1, name.length - 2);
                    name = ctx.stylize(name, "name");
                  } else {
                    name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                    name = ctx.stylize(name, "string");
                  }
                }
                return name + ": " + str;
              }
              function reduceToSingleString(output, base, braces) {
                var numLinesEst = 0;
                var length = output.reduce(function(prev, cur) {
                  numLinesEst++;
                  if (cur.indexOf("\n") >= 0)
                    numLinesEst++;
                  return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                }, 0);
                if (length > 60) {
                  return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                }
                return braces[0] + base + " " + output.join(", ") + " " + braces[1];
              }
              function isArray(ar) {
                return Array.isArray(ar);
              }
              exports2.isArray = isArray;
              function isBoolean(arg) {
                return typeof arg === "boolean";
              }
              exports2.isBoolean = isBoolean;
              function isNull(arg) {
                return arg === null;
              }
              exports2.isNull = isNull;
              function isNullOrUndefined(arg) {
                return arg == null;
              }
              exports2.isNullOrUndefined = isNullOrUndefined;
              function isNumber(arg) {
                return typeof arg === "number";
              }
              exports2.isNumber = isNumber;
              function isString(arg) {
                return typeof arg === "string";
              }
              exports2.isString = isString;
              function isSymbol(arg) {
                return typeof arg === "symbol";
              }
              exports2.isSymbol = isSymbol;
              function isUndefined(arg) {
                return arg === void 0;
              }
              exports2.isUndefined = isUndefined;
              function isRegExp(re) {
                return isObject(re) && objectToString(re) === "[object RegExp]";
              }
              exports2.isRegExp = isRegExp;
              function isObject(arg) {
                return typeof arg === "object" && arg !== null;
              }
              exports2.isObject = isObject;
              function isDate(d) {
                return isObject(d) && objectToString(d) === "[object Date]";
              }
              exports2.isDate = isDate;
              function isError(e) {
                return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
              }
              exports2.isError = isError;
              function isFunction(arg) {
                return typeof arg === "function";
              }
              exports2.isFunction = isFunction;
              function isPrimitive(arg) {
                return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
                typeof arg === "undefined";
              }
              exports2.isPrimitive = isPrimitive;
              exports2.isBuffer = __webpack_require__(40);
              function objectToString(o) {
                return Object.prototype.toString.call(o);
              }
              function pad(n) {
                return n < 10 ? "0" + n.toString(10) : n.toString(10);
              }
              var months = [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec"
              ];
              function timestamp() {
                var d = /* @__PURE__ */ new Date();
                var time = [
                  pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())
                ].join(":");
                return [d.getDate(), months[d.getMonth()], time].join(" ");
              }
              exports2.log = function() {
                console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
              };
              exports2.inherits = __webpack_require__(39);
              exports2._extend = function(origin, add) {
                if (!add || !isObject(add))
                  return origin;
                var keys = Object.keys(add);
                var i = keys.length;
                while (i--) {
                  origin[keys[i]] = add[keys[i]];
                }
                return origin;
              };
              function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
              }
            }).call(exports2, __webpack_require__(5), __webpack_require__(7));
          },
          /* 17 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            (function(global) {
              function compare(a, b) {
                if (a === b) {
                  return 0;
                }
                var x = a.length;
                var y = b.length;
                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                  if (a[i] !== b[i]) {
                    x = a[i];
                    y = b[i];
                    break;
                  }
                }
                if (x < y) {
                  return -1;
                }
                if (y < x) {
                  return 1;
                }
                return 0;
              }
              function isBuffer(b) {
                if (global.Buffer && typeof global.Buffer.isBuffer === "function") {
                  return global.Buffer.isBuffer(b);
                }
                return !!(b != null && b._isBuffer);
              }
              var util = __webpack_require__(16);
              var hasOwn = Object.prototype.hasOwnProperty;
              var pSlice = Array.prototype.slice;
              var functionsHaveNames = function() {
                return (function foo() {
                }).name === "foo";
              }();
              function pToString(obj) {
                return Object.prototype.toString.call(obj);
              }
              function isView(arrbuf) {
                if (isBuffer(arrbuf)) {
                  return false;
                }
                if (typeof global.ArrayBuffer !== "function") {
                  return false;
                }
                if (typeof ArrayBuffer.isView === "function") {
                  return ArrayBuffer.isView(arrbuf);
                }
                if (!arrbuf) {
                  return false;
                }
                if (arrbuf instanceof DataView) {
                  return true;
                }
                if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
                  return true;
                }
                return false;
              }
              var assert = module2.exports = ok;
              var regex = /\s*function\s+([^\(\s]*)\s*/;
              function getName(func) {
                if (!util.isFunction(func)) {
                  return;
                }
                if (functionsHaveNames) {
                  return func.name;
                }
                var str = func.toString();
                var match = str.match(regex);
                return match && match[1];
              }
              assert.AssertionError = function AssertionError(options) {
                this.name = "AssertionError";
                this.actual = options.actual;
                this.expected = options.expected;
                this.operator = options.operator;
                if (options.message) {
                  this.message = options.message;
                  this.generatedMessage = false;
                } else {
                  this.message = getMessage(this);
                  this.generatedMessage = true;
                }
                var stackStartFunction = options.stackStartFunction || fail;
                if (Error.captureStackTrace) {
                  Error.captureStackTrace(this, stackStartFunction);
                } else {
                  var err = new Error();
                  if (err.stack) {
                    var out = err.stack;
                    var fn_name = getName(stackStartFunction);
                    var idx = out.indexOf("\n" + fn_name);
                    if (idx >= 0) {
                      var next_line = out.indexOf("\n", idx + 1);
                      out = out.substring(next_line + 1);
                    }
                    this.stack = out;
                  }
                }
              };
              util.inherits(assert.AssertionError, Error);
              function truncate(s, n) {
                if (typeof s === "string") {
                  return s.length < n ? s : s.slice(0, n);
                } else {
                  return s;
                }
              }
              function inspect(something) {
                if (functionsHaveNames || !util.isFunction(something)) {
                  return util.inspect(something);
                }
                var rawname = getName(something);
                var name = rawname ? ": " + rawname : "";
                return "[Function" + name + "]";
              }
              function getMessage(self) {
                return truncate(inspect(self.actual), 128) + " " + self.operator + " " + truncate(inspect(self.expected), 128);
              }
              function fail(actual, expected, message, operator, stackStartFunction) {
                throw new assert.AssertionError({
                  message,
                  actual,
                  expected,
                  operator,
                  stackStartFunction
                });
              }
              assert.fail = fail;
              function ok(value, message) {
                if (!value)
                  fail(value, true, message, "==", assert.ok);
              }
              assert.ok = ok;
              assert.equal = function equal(actual, expected, message) {
                if (actual != expected)
                  fail(actual, expected, message, "==", assert.equal);
              };
              assert.notEqual = function notEqual(actual, expected, message) {
                if (actual == expected) {
                  fail(actual, expected, message, "!=", assert.notEqual);
                }
              };
              assert.deepEqual = function deepEqual(actual, expected, message) {
                if (!_deepEqual(actual, expected, false)) {
                  fail(actual, expected, message, "deepEqual", assert.deepEqual);
                }
              };
              assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                if (!_deepEqual(actual, expected, true)) {
                  fail(actual, expected, message, "deepStrictEqual", assert.deepStrictEqual);
                }
              };
              function _deepEqual(actual, expected, strict, memos) {
                if (actual === expected) {
                  return true;
                } else if (isBuffer(actual) && isBuffer(expected)) {
                  return compare(actual, expected) === 0;
                } else if (util.isDate(actual) && util.isDate(expected)) {
                  return actual.getTime() === expected.getTime();
                } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
                  return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
                } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
                  return strict ? actual === expected : actual == expected;
                } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
                  return compare(
                    new Uint8Array(actual.buffer),
                    new Uint8Array(expected.buffer)
                  ) === 0;
                } else if (isBuffer(actual) !== isBuffer(expected)) {
                  return false;
                } else {
                  memos = memos || { actual: [], expected: [] };
                  var actualIndex = memos.actual.indexOf(actual);
                  if (actualIndex !== -1) {
                    if (actualIndex === memos.expected.indexOf(expected)) {
                      return true;
                    }
                  }
                  memos.actual.push(actual);
                  memos.expected.push(expected);
                  return objEquiv(actual, expected, strict, memos);
                }
              }
              function isArguments(object) {
                return Object.prototype.toString.call(object) == "[object Arguments]";
              }
              function objEquiv(a, b, strict, actualVisitedObjects) {
                if (a === null || a === void 0 || b === null || b === void 0)
                  return false;
                if (util.isPrimitive(a) || util.isPrimitive(b))
                  return a === b;
                if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
                  return false;
                var aIsArgs = isArguments(a);
                var bIsArgs = isArguments(b);
                if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
                  return false;
                if (aIsArgs) {
                  a = pSlice.call(a);
                  b = pSlice.call(b);
                  return _deepEqual(a, b, strict);
                }
                var ka = objectKeys(a);
                var kb = objectKeys(b);
                var key, i;
                if (ka.length !== kb.length)
                  return false;
                ka.sort();
                kb.sort();
                for (i = ka.length - 1; i >= 0; i--) {
                  if (ka[i] !== kb[i])
                    return false;
                }
                for (i = ka.length - 1; i >= 0; i--) {
                  key = ka[i];
                  if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
                    return false;
                }
                return true;
              }
              assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                if (_deepEqual(actual, expected, false)) {
                  fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
                }
              };
              assert.notDeepStrictEqual = notDeepStrictEqual;
              function notDeepStrictEqual(actual, expected, message) {
                if (_deepEqual(actual, expected, true)) {
                  fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
                }
              }
              assert.strictEqual = function strictEqual(actual, expected, message) {
                if (actual !== expected) {
                  fail(actual, expected, message, "===", assert.strictEqual);
                }
              };
              assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                if (actual === expected) {
                  fail(actual, expected, message, "!==", assert.notStrictEqual);
                }
              };
              function expectedException(actual, expected) {
                if (!actual || !expected) {
                  return false;
                }
                if (Object.prototype.toString.call(expected) == "[object RegExp]") {
                  return expected.test(actual);
                }
                try {
                  if (actual instanceof expected) {
                    return true;
                  }
                } catch (e) {
                }
                if (Error.isPrototypeOf(expected)) {
                  return false;
                }
                return expected.call({}, actual) === true;
              }
              function _tryBlock(block) {
                var error;
                try {
                  block();
                } catch (e) {
                  error = e;
                }
                return error;
              }
              function _throws(shouldThrow, block, expected, message) {
                var actual;
                if (typeof block !== "function") {
                  throw new TypeError('"block" argument must be a function');
                }
                if (typeof expected === "string") {
                  message = expected;
                  expected = null;
                }
                actual = _tryBlock(block);
                message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
                if (shouldThrow && !actual) {
                  fail(actual, expected, "Missing expected exception" + message);
                }
                var userProvidedMessage = typeof message === "string";
                var isUnwantedException = !shouldThrow && util.isError(actual);
                var isUnexpectedException = !shouldThrow && actual && !expected;
                if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
                  fail(actual, expected, "Got unwanted exception" + message);
                }
                if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
                  throw actual;
                }
              }
              assert.throws = function(block, error, message) {
                _throws(true, block, error, message);
              };
              assert.doesNotThrow = function(block, error, message) {
                _throws(false, block, error, message);
              };
              assert.ifError = function(err) {
                if (err)
                  throw err;
              };
              var objectKeys = Object.keys || function(obj) {
                var keys = [];
                for (var key in obj) {
                  if (hasOwn.call(obj, key))
                    keys.push(key);
                }
                return keys;
              };
            }).call(exports2, __webpack_require__(5));
          },
          /* 18 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            (function(Buffer) {
              var internals = {};
              exports2.escapeJavaScript = function(input) {
                if (!input) {
                  return "";
                }
                var escaped = "";
                for (var i = 0; i < input.length; ++i) {
                  var charCode = input.charCodeAt(i);
                  if (internals.isSafe(charCode)) {
                    escaped += input[i];
                  } else {
                    escaped += internals.escapeJavaScriptChar(charCode);
                  }
                }
                return escaped;
              };
              exports2.escapeHtml = function(input) {
                if (!input) {
                  return "";
                }
                var escaped = "";
                for (var i = 0; i < input.length; ++i) {
                  var charCode = input.charCodeAt(i);
                  if (internals.isSafe(charCode)) {
                    escaped += input[i];
                  } else {
                    escaped += internals.escapeHtmlChar(charCode);
                  }
                }
                return escaped;
              };
              exports2.escapeJson = function(input) {
                if (!input) {
                  return "";
                }
                var lessThan = 60;
                var greaterThan = 62;
                var andSymbol = 38;
                var lineSeperator = 8232;
                var charCode = void 0;
                return input.replace(/[<>&\u2028\u2029]/g, function(match) {
                  charCode = match.charCodeAt(0);
                  if (charCode === lessThan) {
                    return "\\u003c";
                  } else if (charCode === greaterThan) {
                    return "\\u003e";
                  } else if (charCode === andSymbol) {
                    return "\\u0026";
                  } else if (charCode === lineSeperator) {
                    return "\\u2028";
                  }
                  return "\\u2029";
                });
              };
              internals.escapeJavaScriptChar = function(charCode) {
                if (charCode >= 256) {
                  return "\\u" + internals.padLeft("" + charCode, 4);
                }
                var hexValue = Buffer.from(String.fromCharCode(charCode), "ascii").toString("hex");
                return "\\x" + internals.padLeft(hexValue, 2);
              };
              internals.escapeHtmlChar = function(charCode) {
                var namedEscape = internals.namedHtml[charCode];
                if (typeof namedEscape !== "undefined") {
                  return namedEscape;
                }
                if (charCode >= 256) {
                  return "&#" + charCode + ";";
                }
                var hexValue = Buffer.from(String.fromCharCode(charCode), "ascii").toString("hex");
                return "&#x" + internals.padLeft(hexValue, 2) + ";";
              };
              internals.padLeft = function(str, len) {
                while (str.length < len) {
                  str = "0" + str;
                }
                return str;
              };
              internals.isSafe = function(charCode) {
                return typeof internals.safeCharCodes[charCode] !== "undefined";
              };
              internals.namedHtml = {
                "38": "&amp;",
                "60": "&lt;",
                "62": "&gt;",
                "34": "&quot;",
                "160": "&nbsp;",
                "162": "&cent;",
                "163": "&pound;",
                "164": "&curren;",
                "169": "&copy;",
                "174": "&reg;"
              };
              internals.safeCharCodes = function() {
                var safe = {};
                for (var i = 32; i < 123; ++i) {
                  if (i >= 97 || // a-z
                  i >= 65 && i <= 90 || // A-Z
                  i >= 48 && i <= 57 || // 0-9
                  i === 32 || // space
                  i === 46 || // .
                  i === 44 || // ,
                  i === 45 || // -
                  i === 58 || // :
                  i === 95) {
                    safe[i] = null;
                  }
                }
                return safe;
              }();
            }).call(exports2, __webpack_require__(3).Buffer);
          },
          /* 19 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            (function(Buffer) {
              var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                return typeof obj;
              } : function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              };
              var Punycode = __webpack_require__(38);
              var internals = {
                hasOwn: Object.prototype.hasOwnProperty,
                indexOf: Array.prototype.indexOf,
                defaultThreshold: 16,
                maxIPv6Groups: 8,
                categories: {
                  valid: 1,
                  dnsWarn: 7,
                  rfc5321: 15,
                  cfws: 31,
                  deprecated: 63,
                  rfc5322: 127,
                  error: 255
                },
                diagnoses: {
                  // Address is valid
                  valid: 0,
                  // Address is valid for SMTP but has unusual elements
                  rfc5321TLD: 9,
                  rfc5321TLDNumeric: 10,
                  rfc5321QuotedString: 11,
                  rfc5321AddressLiteral: 12,
                  // Address is valid for message, but must be modified for envelope
                  cfwsComment: 17,
                  cfwsFWS: 18,
                  // Address contains non-ASCII when the allowUnicode option is false
                  // Has to be > internals.defaultThreshold so that it's rejected
                  // without an explicit errorLevel:
                  undesiredNonAscii: 25,
                  // Address contains deprecated elements, but may still be valid in some contexts
                  deprecatedLocalPart: 33,
                  deprecatedFWS: 34,
                  deprecatedQTEXT: 35,
                  deprecatedQP: 36,
                  deprecatedComment: 37,
                  deprecatedCTEXT: 38,
                  deprecatedIPv6: 39,
                  deprecatedCFWSNearAt: 49,
                  // Address is only valid according to broad definition in RFC 5322, but is otherwise invalid
                  rfc5322Domain: 65,
                  rfc5322TooLong: 66,
                  rfc5322LocalTooLong: 67,
                  rfc5322DomainTooLong: 68,
                  rfc5322LabelTooLong: 69,
                  rfc5322DomainLiteral: 70,
                  rfc5322DomainLiteralOBSDText: 71,
                  rfc5322IPv6GroupCount: 72,
                  rfc5322IPv62x2xColon: 73,
                  rfc5322IPv6BadCharacter: 74,
                  rfc5322IPv6MaxGroups: 75,
                  rfc5322IPv6ColonStart: 76,
                  rfc5322IPv6ColonEnd: 77,
                  // Address is invalid for any purpose
                  errExpectingDTEXT: 129,
                  errNoLocalPart: 130,
                  errNoDomain: 131,
                  errConsecutiveDots: 132,
                  errATEXTAfterCFWS: 133,
                  errATEXTAfterQS: 134,
                  errATEXTAfterDomainLiteral: 135,
                  errExpectingQPair: 136,
                  errExpectingATEXT: 137,
                  errExpectingQTEXT: 138,
                  errExpectingCTEXT: 139,
                  errBackslashEnd: 140,
                  errDotStart: 141,
                  errDotEnd: 142,
                  errDomainHyphenStart: 143,
                  errDomainHyphenEnd: 144,
                  errUnclosedQuotedString: 145,
                  errUnclosedComment: 146,
                  errUnclosedDomainLiteral: 147,
                  errFWSCRLFx2: 148,
                  errFWSCRLFEnd: 149,
                  errCRNoLF: 150,
                  errUnknownTLD: 160,
                  errDomainTooShort: 161
                },
                components: {
                  localpart: 0,
                  domain: 1,
                  literal: 2,
                  contextComment: 3,
                  contextFWS: 4,
                  contextQuotedString: 5,
                  contextQuotedPair: 6
                }
              };
              internals.specials = function() {
                var specials = '()<>[]:;@\\,."';
                var lookup = new Array(256);
                lookup.fill(false);
                for (var i = 0; i < specials.length; ++i) {
                  lookup[specials.codePointAt(i)] = true;
                }
                return function(code) {
                  return lookup[code];
                };
              }();
              internals.c0Controls = function() {
                var lookup = new Array(256);
                lookup.fill(false);
                for (var i = 0; i < 33; ++i) {
                  lookup[i] = true;
                }
                return function(code) {
                  return lookup[code];
                };
              }();
              internals.c1Controls = function() {
                var lookup = new Array(256);
                lookup.fill(false);
                for (var i = 127; i < 160; ++i) {
                  lookup[i] = true;
                }
                return function(code) {
                  return lookup[code];
                };
              }();
              internals.regex = {
                ipV4: /\b(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
                ipV6: /^[a-fA-F\d]{0,4}$/
              };
              internals.normalizeSupportsNul = "\0".normalize("NFC") === "\0";
              internals.nulNormalize = function(email) {
                return email.split("\0").map(function(part) {
                  return part.normalize("NFC");
                }).join("\0");
              };
              internals.normalize = function(email) {
                if (!internals.normalizeSupportsNul && email.indexOf("\0") >= 0) {
                  return internals.nulNormalize(email);
                }
                return email.normalize("NFC");
              };
              internals.checkIpV6 = function(items) {
                return items.every(function(value) {
                  return internals.regex.ipV6.test(value);
                });
              };
              internals.validDomain = function(tldAtom, options) {
                if (options.tldBlacklist) {
                  if (Array.isArray(options.tldBlacklist)) {
                    return internals.indexOf.call(options.tldBlacklist, tldAtom) === -1;
                  }
                  return !internals.hasOwn.call(options.tldBlacklist, tldAtom);
                }
                if (Array.isArray(options.tldWhitelist)) {
                  return internals.indexOf.call(options.tldWhitelist, tldAtom) !== -1;
                }
                return internals.hasOwn.call(options.tldWhitelist, tldAtom);
              };
              exports2.validate = internals.validate = function(email, options, callback) {
                options = options || {};
                email = internals.normalize(email);
                if (typeof options === "function") {
                  callback = options;
                  options = {};
                }
                if (typeof callback !== "function") {
                  callback = null;
                }
                var diagnose = void 0;
                var threshold = void 0;
                if (typeof options.errorLevel === "number") {
                  diagnose = true;
                  threshold = options.errorLevel;
                } else {
                  diagnose = !!options.errorLevel;
                  threshold = internals.diagnoses.valid;
                }
                if (options.tldWhitelist) {
                  if (typeof options.tldWhitelist === "string") {
                    options.tldWhitelist = [options.tldWhitelist];
                  } else if (_typeof(options.tldWhitelist) !== "object") {
                    throw new TypeError("expected array or object tldWhitelist");
                  }
                }
                if (options.tldBlacklist) {
                  if (typeof options.tldBlacklist === "string") {
                    options.tldBlacklist = [options.tldBlacklist];
                  } else if (_typeof(options.tldBlacklist) !== "object") {
                    throw new TypeError("expected array or object tldBlacklist");
                  }
                }
                if (options.minDomainAtoms && (options.minDomainAtoms !== (+options.minDomainAtoms | 0) || options.minDomainAtoms < 0)) {
                  throw new TypeError("expected positive integer minDomainAtoms");
                }
                var maxResult = internals.diagnoses.valid;
                var updateResult = function updateResult2(value) {
                  if (value > maxResult) {
                    maxResult = value;
                  }
                };
                var allowUnicode = options.allowUnicode === void 0 || !!options.allowUnicode;
                if (!allowUnicode && /[^\x00-\x7f]/.test(email)) {
                  updateResult(internals.diagnoses.undesiredNonAscii);
                }
                var context = {
                  now: internals.components.localpart,
                  prev: internals.components.localpart,
                  stack: [internals.components.localpart]
                };
                var prevToken = "";
                var parseData = {
                  local: "",
                  domain: ""
                };
                var atomData = {
                  locals: [""],
                  domains: [""]
                };
                var elementCount = 0;
                var elementLength = 0;
                var crlfCount = 0;
                var charCode = void 0;
                var hyphenFlag = false;
                var assertEnd = false;
                var emailLength = email.length;
                var token = void 0;
                for (var i = 0; i < emailLength; i += token.length) {
                  token = String.fromCodePoint(email.codePointAt(i));
                  switch (context.now) {
                    case internals.components.localpart:
                      switch (token) {
                        case "(":
                          if (elementLength === 0) {
                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsComment : internals.diagnoses.deprecatedComment);
                          } else {
                            updateResult(internals.diagnoses.cfwsComment);
                            assertEnd = true;
                          }
                          context.stack.push(context.now);
                          context.now = internals.components.contextComment;
                          break;
                        case ".":
                          if (elementLength === 0) {
                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);
                          } else {
                            if (assertEnd) {
                              updateResult(internals.diagnoses.deprecatedLocalPart);
                            }
                            assertEnd = false;
                            elementLength = 0;
                            ++elementCount;
                            parseData.local += token;
                            atomData.locals[elementCount] = "";
                          }
                          break;
                        case '"':
                          if (elementLength === 0) {
                            updateResult(elementCount === 0 ? internals.diagnoses.rfc5321QuotedString : internals.diagnoses.deprecatedLocalPart);
                            parseData.local += token;
                            atomData.locals[elementCount] += token;
                            elementLength += Buffer.byteLength(token, "utf8");
                            assertEnd = true;
                            context.stack.push(context.now);
                            context.now = internals.components.contextQuotedString;
                          } else {
                            updateResult(internals.diagnoses.errExpectingATEXT);
                          }
                          break;
                        case "\r":
                          if (emailLength === ++i || email[i] !== "\n") {
                            updateResult(internals.diagnoses.errCRNoLF);
                            break;
                          }
                        case " ":
                        case "	":
                          if (elementLength === 0) {
                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsFWS : internals.diagnoses.deprecatedFWS);
                          } else {
                            assertEnd = true;
                          }
                          context.stack.push(context.now);
                          context.now = internals.components.contextFWS;
                          prevToken = token;
                          break;
                        case "@":
                          if (context.stack.length !== 1) {
                            throw new Error("unexpected item on context stack");
                          }
                          if (parseData.local.length === 0) {
                            updateResult(internals.diagnoses.errNoLocalPart);
                          } else if (elementLength === 0) {
                            updateResult(internals.diagnoses.errDotEnd);
                          } else if (Buffer.byteLength(parseData.local, "utf8") > 64) {
                            updateResult(internals.diagnoses.rfc5322LocalTooLong);
                          } else if (context.prev === internals.components.contextComment || context.prev === internals.components.contextFWS) {
                            updateResult(internals.diagnoses.deprecatedCFWSNearAt);
                          }
                          context.now = internals.components.domain;
                          context.stack[0] = internals.components.domain;
                          elementCount = 0;
                          elementLength = 0;
                          assertEnd = false;
                          break;
                        default:
                          if (assertEnd) {
                            switch (context.prev) {
                              case internals.components.contextComment:
                              case internals.components.contextFWS:
                                updateResult(internals.diagnoses.errATEXTAfterCFWS);
                                break;
                              case internals.components.contextQuotedString:
                                updateResult(internals.diagnoses.errATEXTAfterQS);
                                break;
                              default:
                                throw new Error("more atext found where none is allowed, but unrecognized prev context: " + context.prev);
                            }
                          } else {
                            context.prev = context.now;
                            charCode = token.codePointAt(0);
                            if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {
                              updateResult(internals.diagnoses.errExpectingATEXT);
                            }
                            parseData.local += token;
                            atomData.locals[elementCount] += token;
                            elementLength += Buffer.byteLength(token, "utf8");
                          }
                      }
                      break;
                    case internals.components.domain:
                      switch (token) {
                        case "(":
                          if (elementLength === 0) {
                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedComment);
                          } else {
                            assertEnd = true;
                            updateResult(internals.diagnoses.cfwsComment);
                          }
                          context.stack.push(context.now);
                          context.now = internals.components.contextComment;
                          break;
                        case ".":
                          var punycodeLength = Punycode.encode(atomData.domains[elementCount]).length;
                          if (elementLength === 0) {
                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);
                          } else if (hyphenFlag) {
                            updateResult(internals.diagnoses.errDomainHyphenEnd);
                          } else if (punycodeLength > 63) {
                            updateResult(internals.diagnoses.rfc5322LabelTooLong);
                          }
                          assertEnd = false;
                          elementLength = 0;
                          ++elementCount;
                          atomData.domains[elementCount] = "";
                          parseData.domain += token;
                          break;
                        case "[":
                          if (parseData.domain.length === 0) {
                            assertEnd = true;
                            elementLength += Buffer.byteLength(token, "utf8");
                            context.stack.push(context.now);
                            context.now = internals.components.literal;
                            parseData.domain += token;
                            atomData.domains[elementCount] += token;
                            parseData.literal = "";
                          } else {
                            updateResult(internals.diagnoses.errExpectingATEXT);
                          }
                          break;
                        case "\r":
                          if (emailLength === ++i || email[i] !== "\n") {
                            updateResult(internals.diagnoses.errCRNoLF);
                            break;
                          }
                        case " ":
                        case "	":
                          if (elementLength === 0) {
                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedFWS);
                          } else {
                            updateResult(internals.diagnoses.cfwsFWS);
                            assertEnd = true;
                          }
                          context.stack.push(context.now);
                          context.now = internals.components.contextFWS;
                          prevToken = token;
                          break;
                        default:
                          if (assertEnd) {
                            switch (context.prev) {
                              case internals.components.contextComment:
                              case internals.components.contextFWS:
                                updateResult(internals.diagnoses.errATEXTAfterCFWS);
                                break;
                              case internals.components.literal:
                                updateResult(internals.diagnoses.errATEXTAfterDomainLiteral);
                                break;
                              default:
                                throw new Error("more atext found where none is allowed, but unrecognized prev context: " + context.prev);
                            }
                          }
                          charCode = token.codePointAt(0);
                          hyphenFlag = false;
                          if (internals.specials(charCode) || internals.c0Controls(charCode) || internals.c1Controls(charCode)) {
                            updateResult(internals.diagnoses.errExpectingATEXT);
                          } else if (token === "-") {
                            if (elementLength === 0) {
                              updateResult(internals.diagnoses.errDomainHyphenStart);
                            }
                            hyphenFlag = true;
                          } else if (charCode < 48 || charCode > 122 && charCode < 192 || charCode > 57 && charCode < 65 || charCode > 90 && charCode < 97) {
                            updateResult(internals.diagnoses.rfc5322Domain);
                          }
                          parseData.domain += token;
                          atomData.domains[elementCount] += token;
                          elementLength += Buffer.byteLength(token, "utf8");
                      }
                      break;
                    case internals.components.literal:
                      switch (token) {
                        case "]":
                          if (maxResult < internals.categories.deprecated) {
                            var index = -1;
                            var addressLiteral = parseData.literal;
                            var matchesIP = internals.regex.ipV4.exec(addressLiteral);
                            if (matchesIP) {
                              index = matchesIP.index;
                              if (index !== 0) {
                                addressLiteral = addressLiteral.slice(0, index) + "0:0";
                              }
                            }
                            if (index === 0) {
                              updateResult(internals.diagnoses.rfc5321AddressLiteral);
                            } else if (addressLiteral.slice(0, 5).toLowerCase() !== "ipv6:") {
                              updateResult(internals.diagnoses.rfc5322DomainLiteral);
                            } else {
                              var match = addressLiteral.slice(5);
                              var maxGroups = internals.maxIPv6Groups;
                              var groups = match.split(":");
                              index = match.indexOf("::");
                              if (!~index) {
                                if (groups.length !== maxGroups) {
                                  updateResult(internals.diagnoses.rfc5322IPv6GroupCount);
                                }
                              } else if (index !== match.lastIndexOf("::")) {
                                updateResult(internals.diagnoses.rfc5322IPv62x2xColon);
                              } else {
                                if (index === 0 || index === match.length - 2) {
                                  ++maxGroups;
                                }
                                if (groups.length > maxGroups) {
                                  updateResult(internals.diagnoses.rfc5322IPv6MaxGroups);
                                } else if (groups.length === maxGroups) {
                                  updateResult(internals.diagnoses.deprecatedIPv6);
                                }
                              }
                              if (match[0] === ":" && match[1] !== ":") {
                                updateResult(internals.diagnoses.rfc5322IPv6ColonStart);
                              } else if (match[match.length - 1] === ":" && match[match.length - 2] !== ":") {
                                updateResult(internals.diagnoses.rfc5322IPv6ColonEnd);
                              } else if (internals.checkIpV6(groups)) {
                                updateResult(internals.diagnoses.rfc5321AddressLiteral);
                              } else {
                                updateResult(internals.diagnoses.rfc5322IPv6BadCharacter);
                              }
                            }
                          } else {
                            updateResult(internals.diagnoses.rfc5322DomainLiteral);
                          }
                          parseData.domain += token;
                          atomData.domains[elementCount] += token;
                          elementLength += Buffer.byteLength(token, "utf8");
                          context.prev = context.now;
                          context.now = context.stack.pop();
                          break;
                        case "\\":
                          updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);
                          context.stack.push(context.now);
                          context.now = internals.components.contextQuotedPair;
                          break;
                        case "\r":
                          if (emailLength === ++i || email[i] !== "\n") {
                            updateResult(internals.diagnoses.errCRNoLF);
                            break;
                          }
                        case " ":
                        case "	":
                          updateResult(internals.diagnoses.cfwsFWS);
                          context.stack.push(context.now);
                          context.now = internals.components.contextFWS;
                          prevToken = token;
                          break;
                        default:
                          charCode = token.codePointAt(0);
                          if (charCode !== 127 && internals.c1Controls(charCode) || charCode === 0 || token === "[") {
                            updateResult(internals.diagnoses.errExpectingDTEXT);
                            break;
                          } else if (internals.c0Controls(charCode) || charCode === 127) {
                            updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);
                          }
                          parseData.literal += token;
                          parseData.domain += token;
                          atomData.domains[elementCount] += token;
                          elementLength += Buffer.byteLength(token, "utf8");
                      }
                      break;
                    case internals.components.contextQuotedString:
                      switch (token) {
                        case "\\":
                          context.stack.push(context.now);
                          context.now = internals.components.contextQuotedPair;
                          break;
                        case "\r":
                          if (emailLength === ++i || email[i] !== "\n") {
                            updateResult(internals.diagnoses.errCRNoLF);
                            break;
                          }
                        case "	":
                          parseData.local += " ";
                          atomData.locals[elementCount] += " ";
                          elementLength += Buffer.byteLength(token, "utf8");
                          updateResult(internals.diagnoses.cfwsFWS);
                          context.stack.push(context.now);
                          context.now = internals.components.contextFWS;
                          prevToken = token;
                          break;
                        case '"':
                          parseData.local += token;
                          atomData.locals[elementCount] += token;
                          elementLength += Buffer.byteLength(token, "utf8");
                          context.prev = context.now;
                          context.now = context.stack.pop();
                          break;
                        default:
                          charCode = token.codePointAt(0);
                          if (charCode !== 127 && internals.c1Controls(charCode) || charCode === 0 || charCode === 10) {
                            updateResult(internals.diagnoses.errExpectingQTEXT);
                          } else if (internals.c0Controls(charCode) || charCode === 127) {
                            updateResult(internals.diagnoses.deprecatedQTEXT);
                          }
                          parseData.local += token;
                          atomData.locals[elementCount] += token;
                          elementLength += Buffer.byteLength(token, "utf8");
                      }
                      break;
                    case internals.components.contextQuotedPair:
                      charCode = token.codePointAt(0);
                      if (charCode !== 127 && internals.c1Controls(charCode)) {
                        updateResult(internals.diagnoses.errExpectingQPair);
                      } else if (charCode < 31 && charCode !== 9 || charCode === 127) {
                        updateResult(internals.diagnoses.deprecatedQP);
                      }
                      context.prev = context.now;
                      context.now = context.stack.pop();
                      var escapeToken = "\\" + token;
                      switch (context.now) {
                        case internals.components.contextComment:
                          break;
                        case internals.components.contextQuotedString:
                          parseData.local += escapeToken;
                          atomData.locals[elementCount] += escapeToken;
                          elementLength += 2;
                          break;
                        case internals.components.literal:
                          parseData.domain += escapeToken;
                          atomData.domains[elementCount] += escapeToken;
                          elementLength += 2;
                          break;
                        default:
                          throw new Error("quoted pair logic invoked in an invalid context: " + context.now);
                      }
                      break;
                    case internals.components.contextComment:
                      switch (token) {
                        case "(":
                          context.stack.push(context.now);
                          context.now = internals.components.contextComment;
                          break;
                        case ")":
                          context.prev = context.now;
                          context.now = context.stack.pop();
                          break;
                        case "\\":
                          context.stack.push(context.now);
                          context.now = internals.components.contextQuotedPair;
                          break;
                        case "\r":
                          if (emailLength === ++i || email[i] !== "\n") {
                            updateResult(internals.diagnoses.errCRNoLF);
                            break;
                          }
                        case " ":
                        case "	":
                          updateResult(internals.diagnoses.cfwsFWS);
                          context.stack.push(context.now);
                          context.now = internals.components.contextFWS;
                          prevToken = token;
                          break;
                        default:
                          charCode = token.codePointAt(0);
                          if (charCode === 0 || charCode === 10 || charCode !== 127 && internals.c1Controls(charCode)) {
                            updateResult(internals.diagnoses.errExpectingCTEXT);
                            break;
                          } else if (internals.c0Controls(charCode) || charCode === 127) {
                            updateResult(internals.diagnoses.deprecatedCTEXT);
                          }
                      }
                      break;
                    case internals.components.contextFWS:
                      if (prevToken === "\r") {
                        if (token === "\r") {
                          updateResult(internals.diagnoses.errFWSCRLFx2);
                          break;
                        }
                        if (++crlfCount > 1) {
                          updateResult(internals.diagnoses.deprecatedFWS);
                        } else {
                          crlfCount = 1;
                        }
                      }
                      switch (token) {
                        case "\r":
                          if (emailLength === ++i || email[i] !== "\n") {
                            updateResult(internals.diagnoses.errCRNoLF);
                          }
                          break;
                        case " ":
                        case "	":
                          break;
                        default:
                          if (prevToken === "\r") {
                            updateResult(internals.diagnoses.errFWSCRLFEnd);
                          }
                          crlfCount = 0;
                          context.prev = context.now;
                          context.now = context.stack.pop();
                          --i;
                      }
                      prevToken = token;
                      break;
                    default:
                      throw new Error("unknown context: " + context.now);
                  }
                  if (maxResult > internals.categories.rfc5322) {
                    break;
                  }
                }
                if (maxResult < internals.categories.rfc5322) {
                  var _punycodeLength = Punycode.encode(parseData.domain).length;
                  if (context.now === internals.components.contextQuotedString) {
                    updateResult(internals.diagnoses.errUnclosedQuotedString);
                  } else if (context.now === internals.components.contextQuotedPair) {
                    updateResult(internals.diagnoses.errBackslashEnd);
                  } else if (context.now === internals.components.contextComment) {
                    updateResult(internals.diagnoses.errUnclosedComment);
                  } else if (context.now === internals.components.literal) {
                    updateResult(internals.diagnoses.errUnclosedDomainLiteral);
                  } else if (token === "\r") {
                    updateResult(internals.diagnoses.errFWSCRLFEnd);
                  } else if (parseData.domain.length === 0) {
                    updateResult(internals.diagnoses.errNoDomain);
                  } else if (elementLength === 0) {
                    updateResult(internals.diagnoses.errDotEnd);
                  } else if (hyphenFlag) {
                    updateResult(internals.diagnoses.errDomainHyphenEnd);
                  } else if (_punycodeLength > 255) {
                    updateResult(internals.diagnoses.rfc5322DomainTooLong);
                  } else if (Buffer.byteLength(parseData.local, "utf8") + _punycodeLength + /* '@' */
                  1 > 254) {
                    updateResult(internals.diagnoses.rfc5322TooLong);
                  } else if (elementLength > 63) {
                    updateResult(internals.diagnoses.rfc5322LabelTooLong);
                  } else if (options.minDomainAtoms && atomData.domains.length < options.minDomainAtoms) {
                    updateResult(internals.diagnoses.errDomainTooShort);
                  } else if (options.tldWhitelist || options.tldBlacklist) {
                    var tldAtom = atomData.domains[elementCount];
                    if (!internals.validDomain(tldAtom, options)) {
                      updateResult(internals.diagnoses.errUnknownTLD);
                    }
                  }
                }
                if (maxResult < internals.categories.dnsWarn) {
                  var code = atomData.domains[elementCount].codePointAt(0);
                  if (code <= 57) {
                    updateResult(internals.diagnoses.rfc5321TLDNumeric);
                  }
                }
                if (maxResult < threshold) {
                  maxResult = internals.diagnoses.valid;
                }
                var finishResult = diagnose ? maxResult : maxResult < internals.defaultThreshold;
                if (callback) {
                  callback(finishResult);
                }
                return finishResult;
              };
              exports2.diagnoses = internals.validate.diagnoses = function() {
                var diag = {};
                var keys = Object.keys(internals.diagnoses);
                for (var i = 0; i < keys.length; ++i) {
                  var key = keys[i];
                  diag[key] = internals.diagnoses[key];
                }
                return diag;
              }();
              exports2.normalize = internals.normalize;
            }).call(exports2, __webpack_require__(3).Buffer);
          },
          /* 20 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var internals = {};
            exports2.errors = {
              root: "value",
              key: '"{{!label}}" ',
              messages: {
                wrapArrays: true
              },
              any: {
                unknown: "is not allowed",
                invalid: "contains an invalid value",
                empty: "is not allowed to be empty",
                required: "is required",
                allowOnly: "must be one of {{valids}}",
                default: "threw an error when running default method"
              },
              alternatives: {
                base: "not matching any of the allowed alternatives",
                child: null
              },
              array: {
                base: "must be an array",
                includes: "at position {{pos}} does not match any of the allowed types",
                includesSingle: 'single value of "{{!label}}" does not match any of the allowed types',
                includesOne: "at position {{pos}} fails because {{reason}}",
                includesOneSingle: 'single value of "{{!label}}" fails because {{reason}}',
                includesRequiredUnknowns: "does not contain {{unknownMisses}} required value(s)",
                includesRequiredKnowns: "does not contain {{knownMisses}}",
                includesRequiredBoth: "does not contain {{knownMisses}} and {{unknownMisses}} other required value(s)",
                excludes: "at position {{pos}} contains an excluded value",
                excludesSingle: 'single value of "{{!label}}" contains an excluded value',
                min: "must contain at least {{limit}} items",
                max: "must contain less than or equal to {{limit}} items",
                length: "must contain {{limit}} items",
                ordered: "at position {{pos}} fails because {{reason}}",
                orderedLength: "at position {{pos}} fails because array must contain at most {{limit}} items",
                ref: 'references "{{ref}}" which is not a positive integer',
                sparse: "must not be a sparse array",
                unique: "position {{pos}} contains a duplicate value"
              },
              boolean: {
                base: "must be a boolean"
              },
              binary: {
                base: "must be a buffer or a string",
                min: "must be at least {{limit}} bytes",
                max: "must be less than or equal to {{limit}} bytes",
                length: "must be {{limit}} bytes"
              },
              date: {
                base: "must be a number of milliseconds or valid date string",
                format: "must be a string with one of the following formats {{format}}",
                strict: "must be a valid date",
                min: 'must be larger than or equal to "{{limit}}"',
                max: 'must be less than or equal to "{{limit}}"',
                less: 'must be less than "{{limit}}"',
                greater: 'must be greater than "{{limit}}"',
                isoDate: "must be a valid ISO 8601 date",
                timestamp: {
                  javascript: "must be a valid timestamp or number of milliseconds",
                  unix: "must be a valid timestamp or number of seconds"
                },
                ref: 'references "{{ref}}" which is not a date'
              },
              function: {
                base: "must be a Function",
                arity: "must have an arity of {{n}}",
                minArity: "must have an arity greater or equal to {{n}}",
                maxArity: "must have an arity lesser or equal to {{n}}",
                ref: "must be a Joi reference",
                class: "must be a class"
              },
              lazy: {
                base: "!!schema error: lazy schema must be set",
                schema: "!!schema error: lazy schema function must return a schema"
              },
              object: {
                base: "must be an object",
                child: '!!child "{{!child}}" fails because {{reason}}',
                min: "must have at least {{limit}} children",
                max: "must have less than or equal to {{limit}} children",
                length: "must have {{limit}} children",
                allowUnknown: '!!"{{!child}}" is not allowed',
                with: '!!"{{mainWithLabel}}" missing required peer "{{peerWithLabel}}"',
                without: '!!"{{mainWithLabel}}" conflict with forbidden peer "{{peerWithLabel}}"',
                missing: "must contain at least one of {{peersWithLabels}}",
                xor: "contains a conflict between exclusive peers {{peersWithLabels}}",
                or: "must contain at least one of {{peersWithLabels}}",
                and: "contains {{presentWithLabels}} without its required peers {{missingWithLabels}}",
                nand: '!!"{{mainWithLabel}}" must not exist simultaneously with {{peersWithLabels}}',
                assert: '!!"{{ref}}" validation failed because "{{ref}}" failed to {{message}}',
                rename: {
                  multiple: 'cannot rename child "{{from}}" because multiple renames are disabled and another key was already renamed to "{{to}}"',
                  override: 'cannot rename child "{{from}}" because override is disabled and target "{{to}}" exists',
                  regex: {
                    multiple: 'cannot rename children {{from}} because multiple renames are disabled and another key was already renamed to "{{to}}"',
                    override: 'cannot rename children {{from}} because override is disabled and target "{{to}}" exists'
                  }
                },
                type: 'must be an instance of "{{type}}"',
                schema: "must be a Joi instance"
              },
              number: {
                base: "must be a number",
                min: "must be larger than or equal to {{limit}}",
                max: "must be less than or equal to {{limit}}",
                less: "must be less than {{limit}}",
                greater: "must be greater than {{limit}}",
                float: "must be a float or double",
                integer: "must be an integer",
                negative: "must be a negative number",
                positive: "must be a positive number",
                precision: "must have no more than {{limit}} decimal places",
                ref: 'references "{{ref}}" which is not a number',
                multiple: "must be a multiple of {{multiple}}",
                port: "must be a valid port"
              },
              string: {
                base: "must be a string",
                min: "length must be at least {{limit}} characters long",
                max: "length must be less than or equal to {{limit}} characters long",
                length: "length must be {{limit}} characters long",
                alphanum: "must only contain alpha-numeric characters",
                token: "must only contain alpha-numeric and underscore characters",
                regex: {
                  base: 'with value "{{!value}}" fails to match the required pattern: {{pattern}}',
                  name: 'with value "{{!value}}" fails to match the {{name}} pattern',
                  invert: {
                    base: 'with value "{{!value}}" matches the inverted pattern: {{pattern}}',
                    name: 'with value "{{!value}}" matches the inverted {{name}} pattern'
                  }
                },
                email: "must be a valid email",
                uri: "must be a valid uri",
                uriRelativeOnly: "must be a valid relative uri",
                uriCustomScheme: "must be a valid uri with a scheme matching the {{scheme}} pattern",
                isoDate: "must be a valid ISO 8601 date",
                guid: "must be a valid GUID",
                hex: "must only contain hexadecimal characters",
                hexAlign: "hex decoded representation must be byte aligned",
                base64: "must be a valid base64 string",
                hostname: "must be a valid hostname",
                normalize: "must be unicode normalized in the {{form}} form",
                lowercase: "must only contain lowercase characters",
                uppercase: "must only contain uppercase characters",
                trim: "must not have leading or trailing whitespace",
                creditCard: "must be a credit card",
                ref: 'references "{{ref}}" which is not a number',
                ip: "must be a valid ip address with a {{cidr}} CIDR",
                ipVersion: "must be a valid ip address of one of the following versions {{version}} with a {{cidr}} CIDR"
              }
            };
          },
          /* 21 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var Joi = __webpack_require__(8);
            var internals = {};
            exports2.options = Joi.object({
              abortEarly: Joi.boolean(),
              convert: Joi.boolean(),
              allowUnknown: Joi.boolean(),
              skipFunctions: Joi.boolean(),
              stripUnknown: [Joi.boolean(), Joi.object({ arrays: Joi.boolean(), objects: Joi.boolean() }).or("arrays", "objects")],
              language: Joi.object(),
              presence: Joi.string().only("required", "optional", "forbidden", "ignore"),
              raw: Joi.boolean(),
              context: Joi.object(),
              strip: Joi.boolean(),
              noDefaults: Joi.boolean(),
              escapeHtml: Joi.boolean()
            }).strict();
          },
          /* 22 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            function _defaults(obj, defaults) {
              var keys = Object.getOwnPropertyNames(defaults);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = Object.getOwnPropertyDescriptor(defaults, key);
                if (value && value.configurable && obj[key] === void 0) {
                  Object.defineProperty(obj, key, value);
                }
              }
              return obj;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self, call) {
              if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
            }
            var Any = __webpack_require__(2);
            var Cast = __webpack_require__(4);
            var Ref = __webpack_require__(1);
            var Hoek = __webpack_require__(0);
            var internals = {};
            internals.fastSplice = function(arr, i) {
              var pos = i;
              while (pos < arr.length) {
                arr[pos++] = arr[pos];
              }
              --arr.length;
            };
            internals.Array = function(_Any) {
              _inherits(_class, _Any);
              function _class() {
                _classCallCheck(this, _class);
                var _this = _possibleConstructorReturn(this, _Any.call(this));
                _this._type = "array";
                _this._inner.items = [];
                _this._inner.ordereds = [];
                _this._inner.inclusions = [];
                _this._inner.exclusions = [];
                _this._inner.requireds = [];
                _this._flags.sparse = false;
                return _this;
              }
              _class.prototype._base = function _base(value, state, options) {
                var result = {
                  value
                };
                if (typeof value === "string" && options.convert) {
                  internals.safeParse(value, result);
                }
                var isArray = Array.isArray(result.value);
                var wasArray = isArray;
                if (options.convert && this._flags.single && !isArray) {
                  result.value = [result.value];
                  isArray = true;
                }
                if (!isArray) {
                  result.errors = this.createError("array.base", null, state, options);
                  return result;
                }
                if (this._inner.inclusions.length || this._inner.exclusions.length || this._inner.requireds.length || this._inner.ordereds.length || !this._flags.sparse) {
                  if (wasArray) {
                    result.value = result.value.slice(0);
                  }
                  result.errors = this._checkItems.call(this, result.value, wasArray, state, options);
                  if (result.errors && wasArray && options.convert && this._flags.single) {
                    var previousErrors = result.errors;
                    result.value = [result.value];
                    result.errors = this._checkItems.call(this, result.value, wasArray, state, options);
                    if (result.errors) {
                      result.errors = previousErrors;
                      result.value = result.value[0];
                    }
                  }
                }
                return result;
              };
              _class.prototype._checkItems = function _checkItems(items, wasArray, state, options) {
                var errors = [];
                var errored = void 0;
                var requireds = this._inner.requireds.slice();
                var ordereds = this._inner.ordereds.slice();
                var inclusions = this._inner.inclusions.concat(requireds);
                var il = items.length;
                for (var i = 0; i < il; ++i) {
                  errored = false;
                  var item = items[i];
                  var isValid = false;
                  var key = wasArray ? i : state.key;
                  var path = wasArray ? state.path.concat(i) : state.path;
                  var localState = { key, path, parent: state.parent, reference: state.reference };
                  var res = void 0;
                  if (!this._flags.sparse && item === void 0) {
                    errors.push(this.createError("array.sparse", null, { key: state.key, path: localState.path, pos: i }, options));
                    if (options.abortEarly) {
                      return errors;
                    }
                    ordereds.shift();
                    continue;
                  }
                  for (var j = 0; j < this._inner.exclusions.length; ++j) {
                    res = this._inner.exclusions[j]._validate(item, localState, {});
                    if (!res.errors) {
                      errors.push(this.createError(wasArray ? "array.excludes" : "array.excludesSingle", { pos: i, value: item }, { key: state.key, path: localState.path }, options));
                      errored = true;
                      if (options.abortEarly) {
                        return errors;
                      }
                      ordereds.shift();
                      break;
                    }
                  }
                  if (errored) {
                    continue;
                  }
                  if (this._inner.ordereds.length) {
                    if (ordereds.length > 0) {
                      var ordered = ordereds.shift();
                      res = ordered._validate(item, localState, options);
                      if (!res.errors) {
                        if (ordered._flags.strip) {
                          internals.fastSplice(items, i);
                          --i;
                          --il;
                        } else if (!this._flags.sparse && res.value === void 0) {
                          errors.push(this.createError("array.sparse", null, { key: state.key, path: localState.path, pos: i }, options));
                          if (options.abortEarly) {
                            return errors;
                          }
                          continue;
                        } else {
                          items[i] = res.value;
                        }
                      } else {
                        errors.push(this.createError("array.ordered", { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                        if (options.abortEarly) {
                          return errors;
                        }
                      }
                      continue;
                    } else if (!this._inner.items.length) {
                      errors.push(this.createError("array.orderedLength", { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));
                      if (options.abortEarly) {
                        return errors;
                      }
                      continue;
                    }
                  }
                  var requiredChecks = [];
                  var jl = requireds.length;
                  for (var _j = 0; _j < jl; ++_j) {
                    res = requiredChecks[_j] = requireds[_j]._validate(item, localState, options);
                    if (!res.errors) {
                      items[i] = res.value;
                      isValid = true;
                      internals.fastSplice(requireds, _j);
                      --_j;
                      --jl;
                      if (!this._flags.sparse && res.value === void 0) {
                        errors.push(this.createError("array.sparse", null, { key: state.key, path: localState.path, pos: i }, options));
                        if (options.abortEarly) {
                          return errors;
                        }
                      }
                      break;
                    }
                  }
                  if (isValid) {
                    continue;
                  }
                  var stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.arrays : false;
                  jl = inclusions.length;
                  for (var _j2 = 0; _j2 < jl; ++_j2) {
                    var inclusion = inclusions[_j2];
                    var previousCheck = requireds.indexOf(inclusion);
                    if (previousCheck !== -1) {
                      res = requiredChecks[previousCheck];
                    } else {
                      res = inclusion._validate(item, localState, options);
                      if (!res.errors) {
                        if (inclusion._flags.strip) {
                          internals.fastSplice(items, i);
                          --i;
                          --il;
                        } else if (!this._flags.sparse && res.value === void 0) {
                          errors.push(this.createError("array.sparse", null, { key: state.key, path: localState.path, pos: i }, options));
                          errored = true;
                        } else {
                          items[i] = res.value;
                        }
                        isValid = true;
                        break;
                      }
                    }
                    if (jl === 1) {
                      if (stripUnknown) {
                        internals.fastSplice(items, i);
                        --i;
                        --il;
                        isValid = true;
                        break;
                      }
                      errors.push(this.createError(wasArray ? "array.includesOne" : "array.includesOneSingle", { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                      errored = true;
                      if (options.abortEarly) {
                        return errors;
                      }
                      break;
                    }
                  }
                  if (errored) {
                    continue;
                  }
                  if (this._inner.inclusions.length && !isValid) {
                    if (stripUnknown) {
                      internals.fastSplice(items, i);
                      --i;
                      --il;
                      continue;
                    }
                    errors.push(this.createError(wasArray ? "array.includes" : "array.includesSingle", { pos: i, value: item }, { key: state.key, path: localState.path }, options));
                    if (options.abortEarly) {
                      return errors;
                    }
                  }
                }
                if (requireds.length) {
                  this._fillMissedErrors.call(this, errors, requireds, state, options);
                }
                if (ordereds.length) {
                  this._fillOrderedErrors.call(this, errors, ordereds, state, options);
                }
                return errors.length ? errors : null;
              };
              _class.prototype.describe = function describe() {
                var description = Any.prototype.describe.call(this);
                if (this._inner.ordereds.length) {
                  description.orderedItems = [];
                  for (var i = 0; i < this._inner.ordereds.length; ++i) {
                    description.orderedItems.push(this._inner.ordereds[i].describe());
                  }
                }
                if (this._inner.items.length) {
                  description.items = [];
                  for (var _i = 0; _i < this._inner.items.length; ++_i) {
                    description.items.push(this._inner.items[_i].describe());
                  }
                }
                return description;
              };
              _class.prototype.items = function items() {
                var _this2 = this;
                var obj = this.clone();
                for (var _len = arguments.length, schemas = Array(_len), _key = 0; _key < _len; _key++) {
                  schemas[_key] = arguments[_key];
                }
                Hoek.flatten(schemas).forEach(function(type, index) {
                  try {
                    type = Cast.schema(_this2._currentJoi, type);
                  } catch (castErr) {
                    if (castErr.hasOwnProperty("path")) {
                      castErr.path = index + "." + castErr.path;
                    } else {
                      castErr.path = index;
                    }
                    castErr.message = castErr.message + "(" + castErr.path + ")";
                    throw castErr;
                  }
                  obj._inner.items.push(type);
                  if (type._flags.presence === "required") {
                    obj._inner.requireds.push(type);
                  } else if (type._flags.presence === "forbidden") {
                    obj._inner.exclusions.push(type.optional());
                  } else {
                    obj._inner.inclusions.push(type);
                  }
                });
                return obj;
              };
              _class.prototype.ordered = function ordered() {
                var _this3 = this;
                var obj = this.clone();
                for (var _len2 = arguments.length, schemas = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  schemas[_key2] = arguments[_key2];
                }
                Hoek.flatten(schemas).forEach(function(type, index) {
                  try {
                    type = Cast.schema(_this3._currentJoi, type);
                  } catch (castErr) {
                    if (castErr.hasOwnProperty("path")) {
                      castErr.path = index + "." + castErr.path;
                    } else {
                      castErr.path = index;
                    }
                    castErr.message = castErr.message + "(" + castErr.path + ")";
                    throw castErr;
                  }
                  obj._inner.ordereds.push(type);
                });
                return obj;
              };
              _class.prototype.min = function min(limit) {
                var isRef = Ref.isRef(limit);
                Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, "limit must be a positive integer or reference");
                return this._test("min", limit, function(value, state, options) {
                  var compareTo = void 0;
                  if (isRef) {
                    compareTo = limit(state.reference || state.parent, options);
                    if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                      return this.createError("array.ref", { ref: limit.key }, state, options);
                    }
                  } else {
                    compareTo = limit;
                  }
                  if (value.length >= compareTo) {
                    return value;
                  }
                  return this.createError("array.min", { limit, value }, state, options);
                });
              };
              _class.prototype.max = function max(limit) {
                var isRef = Ref.isRef(limit);
                Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, "limit must be a positive integer or reference");
                return this._test("max", limit, function(value, state, options) {
                  var compareTo = void 0;
                  if (isRef) {
                    compareTo = limit(state.reference || state.parent, options);
                    if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                      return this.createError("array.ref", { ref: limit.key }, state, options);
                    }
                  } else {
                    compareTo = limit;
                  }
                  if (value.length <= compareTo) {
                    return value;
                  }
                  return this.createError("array.max", { limit, value }, state, options);
                });
              };
              _class.prototype.length = function length(limit) {
                var isRef = Ref.isRef(limit);
                Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, "limit must be a positive integer or reference");
                return this._test("length", limit, function(value, state, options) {
                  var compareTo = void 0;
                  if (isRef) {
                    compareTo = limit(state.reference || state.parent, options);
                    if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                      return this.createError("array.ref", { ref: limit.key }, state, options);
                    }
                  } else {
                    compareTo = limit;
                  }
                  if (value.length === compareTo) {
                    return value;
                  }
                  return this.createError("array.length", { limit, value }, state, options);
                });
              };
              _class.prototype.unique = function unique(comparator) {
                Hoek.assert(comparator === void 0 || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
                var settings = {};
                if (typeof comparator === "string") {
                  settings.path = comparator;
                } else if (typeof comparator === "function") {
                  settings.comparator = comparator;
                }
                return this._test("unique", settings, function(value, state, options) {
                  var found = {
                    string: /* @__PURE__ */ Object.create(null),
                    number: /* @__PURE__ */ Object.create(null),
                    undefined: /* @__PURE__ */ Object.create(null),
                    boolean: /* @__PURE__ */ Object.create(null),
                    object: /* @__PURE__ */ new Map(),
                    function: /* @__PURE__ */ new Map(),
                    custom: /* @__PURE__ */ new Map()
                  };
                  var compare = settings.comparator || Hoek.deepEqual;
                  for (var i = 0; i < value.length; ++i) {
                    var item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];
                    var records = settings.comparator ? found.custom : found[typeof item === "undefined" ? "undefined" : _typeof(item)];
                    if (
                      /* $lab:coverage:off$ */
                      records
                    ) {
                      if (records instanceof Map) {
                        var entries = records.entries();
                        var current = void 0;
                        while (!(current = entries.next()).done) {
                          if (compare(current.value[0], item)) {
                            var localState = {
                              key: state.key,
                              path: state.path.concat(i),
                              parent: state.parent,
                              reference: state.reference
                            };
                            var context = {
                              pos: i,
                              value: value[i],
                              dupePos: current.value[1],
                              dupeValue: value[current.value[1]]
                            };
                            if (settings.path) {
                              context.path = settings.path;
                            }
                            return this.createError("array.unique", context, localState, options);
                          }
                        }
                        records.set(item, i);
                      } else {
                        if (records[item] !== void 0) {
                          var _localState = {
                            key: state.key,
                            path: state.path.concat(i),
                            parent: state.parent,
                            reference: state.reference
                          };
                          var _context = {
                            pos: i,
                            value: value[i],
                            dupePos: records[item],
                            dupeValue: value[records[item]]
                          };
                          if (settings.path) {
                            _context.path = settings.path;
                          }
                          return this.createError("array.unique", _context, _localState, options);
                        }
                        records[item] = i;
                      }
                    }
                  }
                  return value;
                });
              };
              _class.prototype.sparse = function sparse(enabled) {
                var value = enabled === void 0 ? true : !!enabled;
                if (this._flags.sparse === value) {
                  return this;
                }
                var obj = this.clone();
                obj._flags.sparse = value;
                return obj;
              };
              _class.prototype.single = function single(enabled) {
                var value = enabled === void 0 ? true : !!enabled;
                if (this._flags.single === value) {
                  return this;
                }
                var obj = this.clone();
                obj._flags.single = value;
                return obj;
              };
              _class.prototype._fillMissedErrors = function _fillMissedErrors(errors, requireds, state, options) {
                var knownMisses = [];
                var unknownMisses = 0;
                for (var i = 0; i < requireds.length; ++i) {
                  var label = requireds[i]._getLabel();
                  if (label) {
                    knownMisses.push(label);
                  } else {
                    ++unknownMisses;
                  }
                }
                if (knownMisses.length) {
                  if (unknownMisses) {
                    errors.push(this.createError("array.includesRequiredBoth", { knownMisses, unknownMisses }, { key: state.key, path: state.path }, options));
                  } else {
                    errors.push(this.createError("array.includesRequiredKnowns", { knownMisses }, { key: state.key, path: state.path }, options));
                  }
                } else {
                  errors.push(this.createError("array.includesRequiredUnknowns", { unknownMisses }, { key: state.key, path: state.path }, options));
                }
              };
              _class.prototype._fillOrderedErrors = function _fillOrderedErrors(errors, ordereds, state, options) {
                var requiredOrdereds = [];
                for (var i = 0; i < ordereds.length; ++i) {
                  var presence = Hoek.reach(ordereds[i], "_flags.presence");
                  if (presence === "required") {
                    requiredOrdereds.push(ordereds[i]);
                  }
                }
                if (requiredOrdereds.length) {
                  this._fillMissedErrors.call(this, errors, requiredOrdereds, state, options);
                }
              };
              return _class;
            }(Any);
            internals.safeParse = function(value, result) {
              try {
                var converted = JSON.parse(value);
                if (Array.isArray(converted)) {
                  result.value = converted;
                }
              } catch (e) {
              }
            };
            module2.exports = new internals.Array();
          },
          /* 23 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            (function(Buffer) {
              function _defaults(obj, defaults) {
                var keys = Object.getOwnPropertyNames(defaults);
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  var value = Object.getOwnPropertyDescriptor(defaults, key);
                  if (value && value.configurable && obj[key] === void 0) {
                    Object.defineProperty(obj, key, value);
                  }
                }
                return obj;
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
                if (superClass)
                  Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
              }
              var Any = __webpack_require__(2);
              var Hoek = __webpack_require__(0);
              var internals = {};
              internals.Binary = function(_Any) {
                _inherits(_class, _Any);
                function _class() {
                  _classCallCheck(this, _class);
                  var _this = _possibleConstructorReturn(this, _Any.call(this));
                  _this._type = "binary";
                  return _this;
                }
                _class.prototype._base = function _base(value, state, options) {
                  var result = {
                    value
                  };
                  if (typeof value === "string" && options.convert) {
                    try {
                      result.value = Buffer.from(value, this._flags.encoding);
                    } catch (e) {
                    }
                  }
                  result.errors = Buffer.isBuffer(result.value) ? null : this.createError("binary.base", null, state, options);
                  return result;
                };
                _class.prototype.encoding = function encoding(_encoding) {
                  Hoek.assert(Buffer.isEncoding(_encoding), "Invalid encoding:", _encoding);
                  if (this._flags.encoding === _encoding) {
                    return this;
                  }
                  var obj = this.clone();
                  obj._flags.encoding = _encoding;
                  return obj;
                };
                _class.prototype.min = function min(limit) {
                  Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, "limit must be a positive integer");
                  return this._test("min", limit, function(value, state, options) {
                    if (value.length >= limit) {
                      return value;
                    }
                    return this.createError("binary.min", { limit, value }, state, options);
                  });
                };
                _class.prototype.max = function max(limit) {
                  Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, "limit must be a positive integer");
                  return this._test("max", limit, function(value, state, options) {
                    if (value.length <= limit) {
                      return value;
                    }
                    return this.createError("binary.max", { limit, value }, state, options);
                  });
                };
                _class.prototype.length = function length(limit) {
                  Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, "limit must be a positive integer");
                  return this._test("length", limit, function(value, state, options) {
                    if (value.length === limit) {
                      return value;
                    }
                    return this.createError("binary.length", { limit, value }, state, options);
                  });
                };
                return _class;
              }(Any);
              module2.exports = new internals.Binary();
            }).call(exports2, __webpack_require__(3).Buffer);
          },
          /* 24 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _defaults(obj, defaults) {
              var keys = Object.getOwnPropertyNames(defaults);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = Object.getOwnPropertyDescriptor(defaults, key);
                if (value && value.configurable && obj[key] === void 0) {
                  Object.defineProperty(obj, key, value);
                }
              }
              return obj;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self, call) {
              if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
            }
            var Any = __webpack_require__(2);
            var Hoek = __webpack_require__(0);
            var internals = {
              Set: __webpack_require__(9)
            };
            internals.Boolean = function(_Any) {
              _inherits(_class, _Any);
              function _class() {
                _classCallCheck(this, _class);
                var _this = _possibleConstructorReturn(this, _Any.call(this));
                _this._type = "boolean";
                _this._flags.insensitive = true;
                _this._inner.truthySet = new internals.Set();
                _this._inner.falsySet = new internals.Set();
                return _this;
              }
              _class.prototype._base = function _base(value, state, options) {
                var result = {
                  value
                };
                if (typeof value === "string" && options.convert) {
                  var normalized = this._flags.insensitive ? value.toLowerCase() : value;
                  result.value = normalized === "true" ? true : normalized === "false" ? false : value;
                }
                if (typeof result.value !== "boolean") {
                  result.value = this._inner.truthySet.has(value, null, null, this._flags.insensitive) ? true : this._inner.falsySet.has(value, null, null, this._flags.insensitive) ? false : value;
                }
                result.errors = typeof result.value === "boolean" ? null : this.createError("boolean.base", null, state, options);
                return result;
              };
              _class.prototype.truthy = function truthy() {
                for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
                  values[_key] = arguments[_key];
                }
                var obj = this.clone();
                values = Hoek.flatten(values);
                for (var i = 0; i < values.length; ++i) {
                  var value = values[i];
                  Hoek.assert(value !== void 0, "Cannot call truthy with undefined");
                  obj._inner.truthySet.add(value);
                }
                return obj;
              };
              _class.prototype.falsy = function falsy() {
                for (var _len2 = arguments.length, values = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  values[_key2] = arguments[_key2];
                }
                var obj = this.clone();
                values = Hoek.flatten(values);
                for (var i = 0; i < values.length; ++i) {
                  var value = values[i];
                  Hoek.assert(value !== void 0, "Cannot call falsy with undefined");
                  obj._inner.falsySet.add(value);
                }
                return obj;
              };
              _class.prototype.insensitive = function insensitive(enabled) {
                var insensitive2 = enabled === void 0 ? true : !!enabled;
                if (this._flags.insensitive === insensitive2) {
                  return this;
                }
                var obj = this.clone();
                obj._flags.insensitive = insensitive2;
                return obj;
              };
              _class.prototype.describe = function describe() {
                var description = Any.prototype.describe.call(this);
                description.truthy = [true].concat(this._inner.truthySet.values());
                description.falsy = [false].concat(this._inner.falsySet.values());
                return description;
              };
              return _class;
            }(Any);
            module2.exports = new internals.Boolean();
          },
          /* 25 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _defaults(obj, defaults) {
              var keys = Object.getOwnPropertyNames(defaults);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = Object.getOwnPropertyDescriptor(defaults, key);
                if (value && value.configurable && obj[key] === void 0) {
                  Object.defineProperty(obj, key, value);
                }
              }
              return obj;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self, call) {
              if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
            }
            var Hoek = __webpack_require__(0);
            var ObjectType = __webpack_require__(13);
            var Ref = __webpack_require__(1);
            var internals = {};
            internals.Func = function(_ObjectType$construct) {
              _inherits(_class, _ObjectType$construct);
              function _class() {
                _classCallCheck(this, _class);
                var _this = _possibleConstructorReturn(this, _ObjectType$construct.call(this));
                _this._flags.func = true;
                return _this;
              }
              _class.prototype.arity = function arity(n) {
                Hoek.assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
                return this._test("arity", n, function(value, state, options) {
                  if (value.length === n) {
                    return value;
                  }
                  return this.createError("function.arity", { n }, state, options);
                });
              };
              _class.prototype.minArity = function minArity(n) {
                Hoek.assert(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
                return this._test("minArity", n, function(value, state, options) {
                  if (value.length >= n) {
                    return value;
                  }
                  return this.createError("function.minArity", { n }, state, options);
                });
              };
              _class.prototype.maxArity = function maxArity(n) {
                Hoek.assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
                return this._test("maxArity", n, function(value, state, options) {
                  if (value.length <= n) {
                    return value;
                  }
                  return this.createError("function.maxArity", { n }, state, options);
                });
              };
              _class.prototype.ref = function ref() {
                return this._test("ref", null, function(value, state, options) {
                  if (Ref.isRef(value)) {
                    return value;
                  }
                  return this.createError("function.ref", null, state, options);
                });
              };
              _class.prototype.class = function _class2() {
                return this._test("class", null, function(value, state, options) {
                  if (/^\s*class\s/.test(value.toString())) {
                    return value;
                  }
                  return this.createError("function.class", null, state, options);
                });
              };
              return _class;
            }(ObjectType.constructor);
            module2.exports = new internals.Func();
          },
          /* 26 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _defaults(obj, defaults) {
              var keys = Object.getOwnPropertyNames(defaults);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = Object.getOwnPropertyDescriptor(defaults, key);
                if (value && value.configurable && obj[key] === void 0) {
                  Object.defineProperty(obj, key, value);
                }
              }
              return obj;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self, call) {
              if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
            }
            var Any = __webpack_require__(2);
            var Hoek = __webpack_require__(0);
            var internals = {};
            internals.Lazy = function(_Any) {
              _inherits(_class, _Any);
              function _class() {
                _classCallCheck(this, _class);
                var _this = _possibleConstructorReturn(this, _Any.call(this));
                _this._type = "lazy";
                return _this;
              }
              _class.prototype._base = function _base(value, state, options) {
                var result = { value };
                var lazy = this._flags.lazy;
                if (!lazy) {
                  result.errors = this.createError("lazy.base", null, state, options);
                  return result;
                }
                var schema = lazy();
                if (!(schema instanceof Any)) {
                  result.errors = this.createError("lazy.schema", null, state, options);
                  return result;
                }
                return schema._validate(value, state, options);
              };
              _class.prototype.set = function set(fn) {
                Hoek.assert(typeof fn === "function", "You must provide a function as first argument");
                var obj = this.clone();
                obj._flags.lazy = fn;
                return obj;
              };
              return _class;
            }(Any);
            module2.exports = new internals.Lazy();
          },
          /* 27 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            function _defaults(obj, defaults) {
              var keys = Object.getOwnPropertyNames(defaults);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = Object.getOwnPropertyDescriptor(defaults, key);
                if (value && value.configurable && obj[key] === void 0) {
                  Object.defineProperty(obj, key, value);
                }
              }
              return obj;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _possibleConstructorReturn(self, call) {
              if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return call && (typeof call === "object" || typeof call === "function") ? call : self;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
              if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
            }
            var Any = __webpack_require__(2);
            var Ref = __webpack_require__(1);
            var Hoek = __webpack_require__(0);
            var internals = {
              precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/
            };
            internals.Number = function(_Any) {
              _inherits(_class, _Any);
              function _class() {
                _classCallCheck(this, _class);
                var _this = _possibleConstructorReturn(this, _Any.call(this));
                _this._type = "number";
                _this._invalids.add(Infinity);
                _this._invalids.add(-Infinity);
                return _this;
              }
              _class.prototype._base = function _base(value, state, options) {
                var result = {
                  errors: null,
                  value
                };
                if (typeof value === "string" && options.convert) {
                  var number = parseFloat(value);
                  result.value = isNaN(number) || !isFinite(value) ? NaN : number;
                }
                var isNumber = typeof result.value === "number" && !isNaN(result.value);
                if (options.convert && "precision" in this._flags && isNumber) {
                  var precision = Math.pow(10, this._flags.precision);
                  result.value = Math.round(result.value * precision) / precision;
                }
                result.errors = isNumber ? null : this.createError("number.base", null, state, options);
                return result;
              };
              _class.prototype.multiple = function multiple(base) {
                var isRef = Ref.isRef(base);
                if (!isRef) {
                  Hoek.assert(typeof base === "number" && isFinite(base), "multiple must be a number");
                  Hoek.assert(base > 0, "multiple must be greater than 0");
                }
                return this._test("multiple", base, function(value, state, options) {
                  var divisor = isRef ? base(state.reference || state.parent, options) : base;
                  if (isRef && (typeof divisor !== "number" || !isFinite(divisor))) {
                    return this.createError("number.ref", { ref: base.key }, state, options);
                  }
                  if (value % divisor === 0) {
                    return value;
                  }
                  return this.createError("number.multiple", { multiple: base, value }, state, options);
                });
              };
              _class.prototype.integer = function integer() {
                return this._test("integer", void 0, function(value, state, options) {
                  return Number.isSafeInteger(value) ? value : this.createError("number.integer", { value }, state, options);
                });
              };
              _class.prototype.negative = function negative() {
                return this._test("negative", void 0, function(value, state, options) {
                  if (value < 0) {
                    return value;
                  }
                  return this.createError("number.negative", { value }, state, options);
                });
              };
              _class.prototype.positive = function positive() {
                return this._test("positive", void 0, function(value, state, options) {
                  if (value > 0) {
                    return value;
                  }
                  return this.createError("number.positive", { value }, state, options);
                });
              };
              _class.prototype.precision = function precision(limit) {
                Hoek.assert(Number.isSafeInteger(limit), "limit must be an integer");
                Hoek.assert(!("precision" in this._flags), "precision already set");
                var obj = this._test("precision", limit, function(value, state, options) {
                  var places = value.toString().match(internals.precisionRx);
                  var decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
                  if (decimals <= limit) {
                    return value;
                  }
                  return this.createError("number.precision", { limit, value }, state, options);
                });
                obj._flags.precision = limit;
                return obj;
              };
              _class.prototype.port = function port() {
                return this._test("port", void 0, function(value, state, options) {
                  if (!Number.isSafeInteger(value) || value < 0 || value > 65535) {
                    return this.createError("number.port", { value }, state, options);
                  }
                  return value;
                });
              };
              return _class;
            }(Any);
            internals.compare = function(type, compare) {
              return function(limit) {
                var isRef = Ref.isRef(limit);
                var isNumber = typeof limit === "number" && !isNaN(limit);
                Hoek.assert(isNumber || isRef, "limit must be a number or reference");
                return this._test(type, limit, function(value, state, options) {
                  var compareTo = void 0;
                  if (isRef) {
                    compareTo = limit(state.reference || state.parent, options);
                    if (!(typeof compareTo === "number" && !isNaN(compareTo))) {
                      return this.createError("number.ref", { ref: limit.key }, state, options);
                    }
                  } else {
                    compareTo = limit;
                  }
                  if (compare(value, compareTo)) {
                    return value;
                  }
                  return this.createError("number." + type, { limit: compareTo, value }, state, options);
                });
              };
            };
            internals.Number.prototype.min = internals.compare("min", function(value, limit) {
              return value >= limit;
            });
            internals.Number.prototype.max = internals.compare("max", function(value, limit) {
              return value <= limit;
            });
            internals.Number.prototype.greater = internals.compare("greater", function(value, limit) {
              return value > limit;
            });
            internals.Number.prototype.less = internals.compare("less", function(value, limit) {
              return value < limit;
            });
            module2.exports = new internals.Number();
          },
          /* 28 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            (function(Buffer) {
              var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                return typeof obj;
              } : function(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              };
              function _defaults(obj, defaults) {
                var keys = Object.getOwnPropertyNames(defaults);
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  var value = Object.getOwnPropertyDescriptor(defaults, key);
                  if (value && value.configurable && obj[key] === void 0) {
                    Object.defineProperty(obj, key, value);
                  }
                }
                return obj;
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              function _possibleConstructorReturn(self, call) {
                if (!self) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return call && (typeof call === "object" || typeof call === "function") ? call : self;
              }
              function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                  throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
                if (superClass)
                  Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
              }
              var Net = __webpack_require__(15);
              var Hoek = __webpack_require__(0);
              var Isemail = void 0;
              var Any = __webpack_require__(2);
              var Ref = __webpack_require__(1);
              var JoiDate = __webpack_require__(12);
              var Uri = __webpack_require__(30);
              var Ip = __webpack_require__(29);
              var internals = {
                uriRegex: Uri.createUriRegex(),
                ipRegex: Ip.createIpRegex(["ipv4", "ipv6", "ipvfuture"], "optional"),
                guidBrackets: {
                  "{": "}",
                  "[": "]",
                  "(": ")",
                  "": ""
                },
                guidVersions: {
                  uuidv1: "1",
                  uuidv2: "2",
                  uuidv3: "3",
                  uuidv4: "4",
                  uuidv5: "5"
                },
                cidrPresences: ["required", "optional", "forbidden"],
                normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"]
              };
              internals.String = function(_Any) {
                _inherits(_class, _Any);
                function _class() {
                  _classCallCheck(this, _class);
                  var _this = _possibleConstructorReturn(this, _Any.call(this));
                  _this._type = "string";
                  _this._invalids.add("");
                  return _this;
                }
                _class.prototype._base = function _base(value, state, options) {
                  if (typeof value === "string" && options.convert) {
                    if (this._flags.normalize) {
                      value = value.normalize(this._flags.normalize);
                    }
                    if (this._flags.case) {
                      value = this._flags.case === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
                    }
                    if (this._flags.trim) {
                      value = value.trim();
                    }
                    if (this._inner.replacements) {
                      for (var i = 0; i < this._inner.replacements.length; ++i) {
                        var replacement = this._inner.replacements[i];
                        value = value.replace(replacement.pattern, replacement.replacement);
                      }
                    }
                    if (this._flags.truncate) {
                      for (var _i = 0; _i < this._tests.length; ++_i) {
                        var test = this._tests[_i];
                        if (test.name === "max") {
                          value = value.slice(0, test.arg);
                          break;
                        }
                      }
                    }
                    if (this._flags.byteAligned && value.length % 2 !== 0) {
                      value = "0" + value;
                    }
                  }
                  return {
                    value,
                    errors: typeof value === "string" ? null : this.createError("string.base", { value }, state, options)
                  };
                };
                _class.prototype.insensitive = function insensitive() {
                  if (this._flags.insensitive) {
                    return this;
                  }
                  var obj = this.clone();
                  obj._flags.insensitive = true;
                  return obj;
                };
                _class.prototype.creditCard = function creditCard() {
                  return this._test("creditCard", void 0, function(value, state, options) {
                    var i = value.length;
                    var sum = 0;
                    var mul = 1;
                    while (i--) {
                      var char = value.charAt(i) * mul;
                      sum = sum + (char - (char > 9) * 9);
                      mul = mul ^ 3;
                    }
                    var check = sum % 10 === 0 && sum > 0;
                    return check ? value : this.createError("string.creditCard", { value }, state, options);
                  });
                };
                _class.prototype.regex = function regex(pattern, patternOptions) {
                  Hoek.assert(pattern instanceof RegExp, "pattern must be a RegExp");
                  var patternObject = {
                    pattern: new RegExp(pattern.source, pattern.ignoreCase ? "i" : void 0)
                    // Future version should break this and forbid unsupported regex flags
                  };
                  if (typeof patternOptions === "string") {
                    patternObject.name = patternOptions;
                  } else if ((typeof patternOptions === "undefined" ? "undefined" : _typeof(patternOptions)) === "object") {
                    patternObject.invert = !!patternOptions.invert;
                    if (patternOptions.name) {
                      patternObject.name = patternOptions.name;
                    }
                  }
                  var errorCode = ["string.regex", patternObject.invert ? ".invert" : "", patternObject.name ? ".name" : ".base"].join("");
                  return this._test("regex", patternObject, function(value, state, options) {
                    var patternMatch = patternObject.pattern.test(value);
                    if (patternMatch ^ patternObject.invert) {
                      return value;
                    }
                    return this.createError(errorCode, { name: patternObject.name, pattern: patternObject.pattern, value }, state, options);
                  });
                };
                _class.prototype.alphanum = function alphanum() {
                  return this._test("alphanum", void 0, function(value, state, options) {
                    if (/^[a-zA-Z0-9]+$/.test(value)) {
                      return value;
                    }
                    return this.createError("string.alphanum", { value }, state, options);
                  });
                };
                _class.prototype.token = function token() {
                  return this._test("token", void 0, function(value, state, options) {
                    if (/^\w+$/.test(value)) {
                      return value;
                    }
                    return this.createError("string.token", { value }, state, options);
                  });
                };
                _class.prototype.email = function email(isEmailOptions) {
                  if (isEmailOptions) {
                    Hoek.assert((typeof isEmailOptions === "undefined" ? "undefined" : _typeof(isEmailOptions)) === "object", "email options must be an object");
                    Hoek.assert(typeof isEmailOptions.checkDNS === "undefined", "checkDNS option is not supported");
                    Hoek.assert(typeof isEmailOptions.tldWhitelist === "undefined" || _typeof(isEmailOptions.tldWhitelist) === "object", "tldWhitelist must be an array or object");
                    Hoek.assert(typeof isEmailOptions.minDomainAtoms === "undefined" || Number.isSafeInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0, "minDomainAtoms must be a positive integer");
                    Hoek.assert(typeof isEmailOptions.errorLevel === "undefined" || typeof isEmailOptions.errorLevel === "boolean" || Number.isSafeInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0, "errorLevel must be a non-negative integer or boolean");
                  }
                  return this._test("email", isEmailOptions, function(value, state, options) {
                    Isemail = Isemail || __webpack_require__(19);
                    try {
                      var result = Isemail.validate(value, isEmailOptions);
                      if (result === true || result === 0) {
                        return value;
                      }
                    } catch (e) {
                    }
                    return this.createError("string.email", { value }, state, options);
                  });
                };
                _class.prototype.ip = function ip() {
                  var ipOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var regex = internals.ipRegex;
                  Hoek.assert((typeof ipOptions === "undefined" ? "undefined" : _typeof(ipOptions)) === "object", "options must be an object");
                  if (ipOptions.cidr) {
                    Hoek.assert(typeof ipOptions.cidr === "string", "cidr must be a string");
                    ipOptions.cidr = ipOptions.cidr.toLowerCase();
                    Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), "cidr must be one of " + internals.cidrPresences.join(", "));
                    if (!ipOptions.version && ipOptions.cidr !== "optional") {
                      regex = Ip.createIpRegex(["ipv4", "ipv6", "ipvfuture"], ipOptions.cidr);
                    }
                  } else {
                    ipOptions.cidr = "optional";
                  }
                  var versions = void 0;
                  if (ipOptions.version) {
                    if (!Array.isArray(ipOptions.version)) {
                      ipOptions.version = [ipOptions.version];
                    }
                    Hoek.assert(ipOptions.version.length >= 1, "version must have at least 1 version specified");
                    versions = [];
                    for (var i = 0; i < ipOptions.version.length; ++i) {
                      var version = ipOptions.version[i];
                      Hoek.assert(typeof version === "string", "version at position " + i + " must be a string");
                      version = version.toLowerCase();
                      Hoek.assert(Ip.versions[version], "version at position " + i + " must be one of " + Object.keys(Ip.versions).join(", "));
                      versions.push(version);
                    }
                    versions = Hoek.unique(versions);
                    regex = Ip.createIpRegex(versions, ipOptions.cidr);
                  }
                  return this._test("ip", ipOptions, function(value, state, options) {
                    if (regex.test(value)) {
                      return value;
                    }
                    if (versions) {
                      return this.createError("string.ipVersion", { value, cidr: ipOptions.cidr, version: versions }, state, options);
                    }
                    return this.createError("string.ip", { value, cidr: ipOptions.cidr }, state, options);
                  });
                };
                _class.prototype.uri = function uri(uriOptions) {
                  var customScheme = "";
                  var allowRelative = false;
                  var relativeOnly = false;
                  var regex = internals.uriRegex;
                  if (uriOptions) {
                    Hoek.assert((typeof uriOptions === "undefined" ? "undefined" : _typeof(uriOptions)) === "object", "options must be an object");
                    if (uriOptions.scheme) {
                      Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === "string" || Array.isArray(uriOptions.scheme), "scheme must be a RegExp, String, or Array");
                      if (!Array.isArray(uriOptions.scheme)) {
                        uriOptions.scheme = [uriOptions.scheme];
                      }
                      Hoek.assert(uriOptions.scheme.length >= 1, "scheme must have at least 1 scheme specified");
                      for (var i = 0; i < uriOptions.scheme.length; ++i) {
                        var scheme = uriOptions.scheme[i];
                        Hoek.assert(scheme instanceof RegExp || typeof scheme === "string", "scheme at position " + i + " must be a RegExp or String");
                        customScheme = customScheme + (customScheme ? "|" : "");
                        if (scheme instanceof RegExp) {
                          customScheme = customScheme + scheme.source;
                        } else {
                          Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(scheme), "scheme at position " + i + " must be a valid scheme");
                          customScheme = customScheme + Hoek.escapeRegex(scheme);
                        }
                      }
                    }
                    if (uriOptions.allowRelative) {
                      allowRelative = true;
                    }
                    if (uriOptions.relativeOnly) {
                      relativeOnly = true;
                    }
                  }
                  if (customScheme || allowRelative || relativeOnly) {
                    regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly);
                  }
                  return this._test("uri", uriOptions, function(value, state, options) {
                    if (regex.test(value)) {
                      return value;
                    }
                    if (relativeOnly) {
                      return this.createError("string.uriRelativeOnly", { value }, state, options);
                    }
                    if (customScheme) {
                      return this.createError("string.uriCustomScheme", { scheme: customScheme, value }, state, options);
                    }
                    return this.createError("string.uri", { value }, state, options);
                  });
                };
                _class.prototype.isoDate = function isoDate() {
                  return this._test("isoDate", void 0, function(value, state, options) {
                    if (JoiDate._isIsoDate(value)) {
                      if (!options.convert) {
                        return value;
                      }
                      var d = new Date(value);
                      if (!isNaN(d.getTime())) {
                        return d.toISOString();
                      }
                    }
                    return this.createError("string.isoDate", { value }, state, options);
                  });
                };
                _class.prototype.guid = function guid(guidOptions) {
                  var versionNumbers = "";
                  if (guidOptions && guidOptions.version) {
                    if (!Array.isArray(guidOptions.version)) {
                      guidOptions.version = [guidOptions.version];
                    }
                    Hoek.assert(guidOptions.version.length >= 1, "version must have at least 1 valid version specified");
                    var versions = /* @__PURE__ */ new Set();
                    for (var i = 0; i < guidOptions.version.length; ++i) {
                      var version = guidOptions.version[i];
                      Hoek.assert(typeof version === "string", "version at position " + i + " must be a string");
                      version = version.toLowerCase();
                      var versionNumber = internals.guidVersions[version];
                      Hoek.assert(versionNumber, "version at position " + i + " must be one of " + Object.keys(internals.guidVersions).join(", "));
                      Hoek.assert(!versions.has(versionNumber), "version at position " + i + " must not be a duplicate.");
                      versionNumbers += versionNumber;
                      versions.add(versionNumber);
                    }
                  }
                  var guidRegex = new RegExp("^([\\[{\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\2?[" + (versionNumbers || "0-9A-F") + "][0-9A-F]{3}\\2?[" + (versionNumbers ? "89AB" : "0-9A-F") + "][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$", "i");
                  return this._test("guid", guidOptions, function(value, state, options) {
                    var results = guidRegex.exec(value);
                    if (!results) {
                      return this.createError("string.guid", { value }, state, options);
                    }
                    if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
                      return this.createError("string.guid", { value }, state, options);
                    }
                    return value;
                  });
                };
                _class.prototype.hex = function hex() {
                  var hexOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  Hoek.assert((typeof hexOptions === "undefined" ? "undefined" : _typeof(hexOptions)) === "object", "hex options must be an object");
                  Hoek.assert(typeof hexOptions.byteAligned === "undefined" || typeof hexOptions.byteAligned === "boolean", "byteAligned must be boolean");
                  var byteAligned = hexOptions.byteAligned === true;
                  var regex = /^[a-f0-9]+$/i;
                  var obj = this._test("hex", regex, function(value, state, options) {
                    if (regex.test(value)) {
                      if (byteAligned && value.length % 2 !== 0) {
                        return this.createError("string.hexAlign", { value }, state, options);
                      }
                      return value;
                    }
                    return this.createError("string.hex", { value }, state, options);
                  });
                  if (byteAligned) {
                    obj._flags.byteAligned = true;
                  }
                  return obj;
                };
                _class.prototype.base64 = function base64() {
                  var base64Options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  Hoek.assert((typeof base64Options === "undefined" ? "undefined" : _typeof(base64Options)) === "object", "base64 options must be an object");
                  Hoek.assert(typeof base64Options.paddingRequired === "undefined" || typeof base64Options.paddingRequired === "boolean", "paddingRequired must be boolean");
                  var paddingRequired = base64Options.paddingRequired === false ? base64Options.paddingRequired : base64Options.paddingRequired || true;
                  var regex = paddingRequired ? (
                    // Padding is required.
                    /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
                  ) : /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/;
                  return this._test("base64", regex, function(value, state, options) {
                    if (regex.test(value)) {
                      return value;
                    }
                    return this.createError("string.base64", { value }, state, options);
                  });
                };
                _class.prototype.hostname = function hostname() {
                  var regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;
                  return this._test("hostname", void 0, function(value, state, options) {
                    if (value.length <= 255 && regex.test(value) || Net.isIPv6(value)) {
                      return value;
                    }
                    return this.createError("string.hostname", { value }, state, options);
                  });
                };
                _class.prototype.normalize = function normalize() {
                  var form = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "NFC";
                  Hoek.assert(Hoek.contain(internals.normalizationForms, form), "normalization form must be one of " + internals.normalizationForms.join(", "));
                  var obj = this._test("normalize", form, function(value, state, options) {
                    if (options.convert || value === value.normalize(form)) {
                      return value;
                    }
                    return this.createError("string.normalize", { value, form }, state, options);
                  });
                  obj._flags.normalize = form;
                  return obj;
                };
                _class.prototype.lowercase = function lowercase() {
                  var obj = this._test("lowercase", void 0, function(value, state, options) {
                    if (options.convert || value === value.toLocaleLowerCase()) {
                      return value;
                    }
                    return this.createError("string.lowercase", { value }, state, options);
                  });
                  obj._flags.case = "lower";
                  return obj;
                };
                _class.prototype.uppercase = function uppercase() {
                  var obj = this._test("uppercase", void 0, function(value, state, options) {
                    if (options.convert || value === value.toLocaleUpperCase()) {
                      return value;
                    }
                    return this.createError("string.uppercase", { value }, state, options);
                  });
                  obj._flags.case = "upper";
                  return obj;
                };
                _class.prototype.trim = function trim() {
                  var obj = this._test("trim", void 0, function(value, state, options) {
                    if (options.convert || value === value.trim()) {
                      return value;
                    }
                    return this.createError("string.trim", { value }, state, options);
                  });
                  obj._flags.trim = true;
                  return obj;
                };
                _class.prototype.replace = function replace(pattern, replacement) {
                  if (typeof pattern === "string") {
                    pattern = new RegExp(Hoek.escapeRegex(pattern), "g");
                  }
                  Hoek.assert(pattern instanceof RegExp, "pattern must be a RegExp");
                  Hoek.assert(typeof replacement === "string", "replacement must be a String");
                  var obj = this.clone();
                  if (!obj._inner.replacements) {
                    obj._inner.replacements = [];
                  }
                  obj._inner.replacements.push({
                    pattern,
                    replacement
                  });
                  return obj;
                };
                _class.prototype.truncate = function truncate(enabled) {
                  var value = enabled === void 0 ? true : !!enabled;
                  if (this._flags.truncate === value) {
                    return this;
                  }
                  var obj = this.clone();
                  obj._flags.truncate = value;
                  return obj;
                };
                return _class;
              }(Any);
              internals.compare = function(type, compare) {
                return function(limit, encoding) {
                  var isRef = Ref.isRef(limit);
                  Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, "limit must be a positive integer or reference");
                  Hoek.assert(!encoding || Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
                  return this._test(type, limit, function(value, state, options) {
                    var compareTo = void 0;
                    if (isRef) {
                      compareTo = limit(state.reference || state.parent, options);
                      if (!Number.isSafeInteger(compareTo)) {
                        return this.createError("string.ref", { ref: limit.key }, state, options);
                      }
                    } else {
                      compareTo = limit;
                    }
                    if (compare(value, compareTo, encoding)) {
                      return value;
                    }
                    return this.createError("string." + type, { limit: compareTo, value, encoding }, state, options);
                  });
                };
              };
              internals.String.prototype.min = internals.compare("min", function(value, limit, encoding) {
                var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
                return length >= limit;
              });
              internals.String.prototype.max = internals.compare("max", function(value, limit, encoding) {
                var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
                return length <= limit;
              });
              internals.String.prototype.length = internals.compare("length", function(value, limit, encoding) {
                var length = encoding ? Buffer.byteLength(value, encoding) : value.length;
                return length === limit;
              });
              internals.String.prototype.uuid = internals.String.prototype.guid;
              module2.exports = new internals.String();
            }).call(exports2, __webpack_require__(3).Buffer);
          },
          /* 29 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var RFC3986 = __webpack_require__(14);
            var internals = {
              Ip: {
                cidrs: {
                  ipv4: {
                    required: "\\/(?:" + RFC3986.ipv4Cidr + ")",
                    optional: "(?:\\/(?:" + RFC3986.ipv4Cidr + "))?",
                    forbidden: ""
                  },
                  ipv6: {
                    required: "\\/" + RFC3986.ipv6Cidr,
                    optional: "(?:\\/" + RFC3986.ipv6Cidr + ")?",
                    forbidden: ""
                  },
                  ipvfuture: {
                    required: "\\/" + RFC3986.ipv6Cidr,
                    optional: "(?:\\/" + RFC3986.ipv6Cidr + ")?",
                    forbidden: ""
                  }
                },
                versions: {
                  ipv4: RFC3986.IPv4address,
                  ipv6: RFC3986.IPv6address,
                  ipvfuture: RFC3986.IPvFuture
                }
              }
            };
            internals.Ip.createIpRegex = function(versions, cidr) {
              var regex = void 0;
              for (var i = 0; i < versions.length; ++i) {
                var version = versions[i];
                if (!regex) {
                  regex = "^(?:" + internals.Ip.versions[version] + internals.Ip.cidrs[version][cidr];
                } else {
                  regex += "|" + internals.Ip.versions[version] + internals.Ip.cidrs[version][cidr];
                }
              }
              return new RegExp(regex + ")$");
            };
            module2.exports = internals.Ip;
          },
          /* 30 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var RFC3986 = __webpack_require__(14);
            var internals = {
              Uri: {
                createUriRegex: function createUriRegex(optionalScheme, allowRelative, relativeOnly) {
                  var scheme = RFC3986.scheme;
                  var prefix = void 0;
                  if (relativeOnly) {
                    prefix = "(?:" + RFC3986.relativeRef + ")";
                  } else {
                    if (optionalScheme) {
                      scheme = "(?:" + optionalScheme + ")";
                    }
                    var withScheme = "(?:" + scheme + ":" + RFC3986.hierPart + ")";
                    prefix = allowRelative ? "(?:" + withScheme + "|" + RFC3986.relativeRef + ")" : withScheme;
                  }
                  return new RegExp("^" + prefix + "(?:\\?" + RFC3986.query + ")?(?:#" + RFC3986.fragment + ")?$");
                }
              }
            };
            module2.exports = internals.Uri;
          },
          /* 31 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var Hoek = __webpack_require__(0);
            var internals = {};
            exports2 = module2.exports = internals.Topo = function() {
              this._items = [];
              this.nodes = [];
            };
            internals.Topo.prototype.add = function(nodes, options) {
              var _this = this;
              options = options || {};
              var before = [].concat(options.before || []);
              var after = [].concat(options.after || []);
              var group = options.group || "?";
              var sort = options.sort || 0;
              Hoek.assert(before.indexOf(group) === -1, "Item cannot come before itself:", group);
              Hoek.assert(before.indexOf("?") === -1, "Item cannot come before unassociated items");
              Hoek.assert(after.indexOf(group) === -1, "Item cannot come after itself:", group);
              Hoek.assert(after.indexOf("?") === -1, "Item cannot come after unassociated items");
              [].concat(nodes).forEach(function(node, i) {
                var item = {
                  seq: _this._items.length,
                  sort,
                  before,
                  after,
                  group,
                  node
                };
                _this._items.push(item);
              });
              var error = this._sort();
              Hoek.assert(!error, "item", group !== "?" ? "added into group " + group : "", "created a dependencies error");
              return this.nodes;
            };
            internals.Topo.prototype.merge = function(others) {
              others = [].concat(others);
              for (var i = 0; i < others.length; ++i) {
                var other = others[i];
                if (other) {
                  for (var j = 0; j < other._items.length; ++j) {
                    var item = Hoek.shallow(other._items[j]);
                    this._items.push(item);
                  }
                }
              }
              this._items.sort(internals.mergeSort);
              for (var _i = 0; _i < this._items.length; ++_i) {
                this._items[_i].seq = _i;
              }
              var error = this._sort();
              Hoek.assert(!error, "merge created a dependencies error");
              return this.nodes;
            };
            internals.mergeSort = function(a, b) {
              return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
            };
            internals.Topo.prototype._sort = function() {
              var graph = {};
              var graphAfters = /* @__PURE__ */ Object.create(null);
              var groups = /* @__PURE__ */ Object.create(null);
              for (var i = 0; i < this._items.length; ++i) {
                var item = this._items[i];
                var seq = item.seq;
                var group = item.group;
                groups[group] = groups[group] || [];
                groups[group].push(seq);
                graph[seq] = item.before;
                var after = item.after;
                for (var j = 0; j < after.length; ++j) {
                  graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);
                }
              }
              var graphNodes = Object.keys(graph);
              for (var _i2 = 0; _i2 < graphNodes.length; ++_i2) {
                var node = graphNodes[_i2];
                var expandedGroups = [];
                var graphNodeItems = Object.keys(graph[node]);
                for (var _j = 0; _j < graphNodeItems.length; ++_j) {
                  var _group = graph[node][graphNodeItems[_j]];
                  groups[_group] = groups[_group] || [];
                  for (var k = 0; k < groups[_group].length; ++k) {
                    expandedGroups.push(groups[_group][k]);
                  }
                }
                graph[node] = expandedGroups;
              }
              var afterNodes = Object.keys(graphAfters);
              for (var _i3 = 0; _i3 < afterNodes.length; ++_i3) {
                var _group2 = afterNodes[_i3];
                if (groups[_group2]) {
                  for (var _j2 = 0; _j2 < groups[_group2].length; ++_j2) {
                    var _node = groups[_group2][_j2];
                    graph[_node] = graph[_node].concat(graphAfters[_group2]);
                  }
                }
              }
              var children = void 0;
              var ancestors = {};
              graphNodes = Object.keys(graph);
              for (var _i4 = 0; _i4 < graphNodes.length; ++_i4) {
                var _node2 = graphNodes[_i4];
                children = graph[_node2];
                for (var _j3 = 0; _j3 < children.length; ++_j3) {
                  ancestors[children[_j3]] = (ancestors[children[_j3]] || []).concat(_node2);
                }
              }
              var visited = {};
              var sorted = [];
              for (var _i5 = 0; _i5 < this._items.length; ++_i5) {
                var next = _i5;
                if (ancestors[_i5]) {
                  next = null;
                  for (var _j4 = 0; _j4 < this._items.length; ++_j4) {
                    if (visited[_j4] === true) {
                      continue;
                    }
                    if (!ancestors[_j4]) {
                      ancestors[_j4] = [];
                    }
                    var shouldSeeCount = ancestors[_j4].length;
                    var seenCount = 0;
                    for (var _k = 0; _k < shouldSeeCount; ++_k) {
                      if (visited[ancestors[_j4][_k]]) {
                        ++seenCount;
                      }
                    }
                    if (seenCount === shouldSeeCount) {
                      next = _j4;
                      break;
                    }
                  }
                }
                if (next !== null) {
                  visited[next] = true;
                  sorted.push(next);
                }
              }
              if (sorted.length !== this._items.length) {
                return new Error("Invalid dependencies");
              }
              var seqIndex = {};
              for (var _i6 = 0; _i6 < this._items.length; ++_i6) {
                var _item = this._items[_i6];
                seqIndex[_item.seq] = _item;
              }
              var sortedNodes = [];
              this._items = sorted.map(function(value) {
                var sortedItem = seqIndex[value];
                sortedNodes.push(sortedItem.node);
                return sortedItem;
              });
              this.nodes = sortedNodes;
            };
          },
          /* 32 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            var Joi = __webpack_require__(8);
            module2.exports = Joi;
          },
          /* 33 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            exports2.byteLength = byteLength;
            exports2.toByteArray = toByteArray;
            exports2.fromByteArray = fromByteArray;
            var lookup = [];
            var revLookup = [];
            var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for (var i = 0, len = code.length; i < len; ++i) {
              lookup[i] = code[i];
              revLookup[code.charCodeAt(i)] = i;
            }
            revLookup["-".charCodeAt(0)] = 62;
            revLookup["_".charCodeAt(0)] = 63;
            function placeHoldersCount(b64) {
              var len2 = b64.length;
              if (len2 % 4 > 0) {
                throw new Error("Invalid string. Length must be a multiple of 4");
              }
              return b64[len2 - 2] === "=" ? 2 : b64[len2 - 1] === "=" ? 1 : 0;
            }
            function byteLength(b64) {
              return b64.length * 3 / 4 - placeHoldersCount(b64);
            }
            function toByteArray(b64) {
              var i2, l, tmp, placeHolders, arr;
              var len2 = b64.length;
              placeHolders = placeHoldersCount(b64);
              arr = new Arr(len2 * 3 / 4 - placeHolders);
              l = placeHolders > 0 ? len2 - 4 : len2;
              var L = 0;
              for (i2 = 0; i2 < l; i2 += 4) {
                tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
                arr[L++] = tmp >> 16 & 255;
                arr[L++] = tmp >> 8 & 255;
                arr[L++] = tmp & 255;
              }
              if (placeHolders === 2) {
                tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
                arr[L++] = tmp & 255;
              } else if (placeHolders === 1) {
                tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
                arr[L++] = tmp >> 8 & 255;
                arr[L++] = tmp & 255;
              }
              return arr;
            }
            function tripletToBase64(num) {
              return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
            }
            function encodeChunk(uint8, start, end) {
              var tmp;
              var output = [];
              for (var i2 = start; i2 < end; i2 += 3) {
                tmp = (uint8[i2] << 16) + (uint8[i2 + 1] << 8) + uint8[i2 + 2];
                output.push(tripletToBase64(tmp));
              }
              return output.join("");
            }
            function fromByteArray(uint8) {
              var tmp;
              var len2 = uint8.length;
              var extraBytes = len2 % 3;
              var output = "";
              var parts = [];
              var maxChunkLength = 16383;
              for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
                parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
              }
              if (extraBytes === 1) {
                tmp = uint8[len2 - 1];
                output += lookup[tmp >> 2];
                output += lookup[tmp << 4 & 63];
                output += "==";
              } else if (extraBytes === 2) {
                tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
                output += lookup[tmp >> 10];
                output += lookup[tmp >> 4 & 63];
                output += lookup[tmp << 2 & 63];
                output += "=";
              }
              parts.push(output);
              return parts.join("");
            }
          },
          /* 34 */
          /***/
          function(module2, exports2) {
            exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
              var e, m;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var nBits = -7;
              var i = isLE ? nBytes - 1 : 0;
              var d = isLE ? -1 : 1;
              var s = buffer[offset + i];
              i += d;
              e = s & (1 << -nBits) - 1;
              s >>= -nBits;
              nBits += eLen;
              for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
              }
              m = e & (1 << -nBits) - 1;
              e >>= -nBits;
              nBits += mLen;
              for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
              }
              if (e === 0) {
                e = 1 - eBias;
              } else if (e === eMax) {
                return m ? NaN : (s ? -1 : 1) * Infinity;
              } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
              }
              return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
            };
            exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
              var e, m, c;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
              var i = isLE ? 0 : nBytes - 1;
              var d = isLE ? 1 : -1;
              var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
              value = Math.abs(value);
              if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
              } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                  e--;
                  c *= 2;
                }
                if (e + eBias >= 1) {
                  value += rt / c;
                } else {
                  value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                  e++;
                  c /= 2;
                }
                if (e + eBias >= eMax) {
                  m = 0;
                  e = eMax;
                } else if (e + eBias >= 1) {
                  m = (value * c - 1) * Math.pow(2, mLen);
                  e = e + eBias;
                } else {
                  m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                  e = 0;
                }
              }
              for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
              }
              e = e << mLen | m;
              eLen += mLen;
              for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
              }
              buffer[offset + i - d] |= s * 128;
            };
          },
          /* 35 */
          /***/
          function(module2, exports2) {
            var toString = {}.toString;
            module2.exports = Array.isArray || function(arr) {
              return toString.call(arr) == "[object Array]";
            };
          },
          /* 36 */
          /***/
          function(module2, exports2) {
            module2.exports = { "_args": [["joi@13.4.0", "/Users/jeff/projects/joi-browser"]], "_development": true, "_from": "joi@13.4.0", "_id": "joi@13.4.0", "_inBundle": false, "_integrity": "sha512-JuK4GjEu6j7zr9FuVe2MAseZ6si/8/HaY0qMAejfDFHp7jcH4OKE937mIHM5VT4xDS0q7lpQbszbxKV9rm0yUg==", "_location": "/joi", "_phantomChildren": {}, "_requested": { "type": "version", "registry": true, "raw": "joi@13.4.0", "name": "joi", "escapedName": "joi", "rawSpec": "13.4.0", "saveSpec": null, "fetchSpec": "13.4.0" }, "_requiredBy": ["#DEV:/"], "_resolved": "https://registry.npmjs.org/joi/-/joi-13.4.0.tgz", "_spec": "13.4.0", "_where": "/Users/jeff/projects/joi-browser", "bugs": { "url": "https://github.com/hapijs/joi/issues" }, "dependencies": { "hoek": "5.x.x", "isemail": "3.x.x", "topo": "3.x.x" }, "description": "Object schema validation", "devDependencies": { "code": "5.x.x", "hapitoc": "1.x.x", "lab": "15.x.x" }, "engines": { "node": ">=8.9.0" }, "homepage": "https://github.com/hapijs/joi", "keywords": ["hapi", "schema", "validation"], "license": "BSD-3-Clause", "main": "lib/index.js", "name": "joi", "repository": { "type": "git", "url": "git://github.com/hapijs/joi.git" }, "scripts": { "test": "lab -t 100 -a code -L", "test-cov-html": "lab -r html -o coverage.html -a code", "test-debug": "lab -a code", "toc": "hapitoc", "version": "npm run toc && git add API.md README.md" }, "version": "13.4.0" };
          },
          /* 37 */
          /***/
          function(module2, exports2, __webpack_require__) {
            (function(process) {
              function normalizeArray(parts, allowAboveRoot) {
                var up = 0;
                for (var i = parts.length - 1; i >= 0; i--) {
                  var last = parts[i];
                  if (last === ".") {
                    parts.splice(i, 1);
                  } else if (last === "..") {
                    parts.splice(i, 1);
                    up++;
                  } else if (up) {
                    parts.splice(i, 1);
                    up--;
                  }
                }
                if (allowAboveRoot) {
                  for (; up--; up) {
                    parts.unshift("..");
                  }
                }
                return parts;
              }
              var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
              var splitPath = function(filename) {
                return splitPathRe.exec(filename).slice(1);
              };
              exports2.resolve = function() {
                var resolvedPath = "", resolvedAbsolute = false;
                for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                  var path = i >= 0 ? arguments[i] : process.cwd();
                  if (typeof path !== "string") {
                    throw new TypeError("Arguments to path.resolve must be strings");
                  } else if (!path) {
                    continue;
                  }
                  resolvedPath = path + "/" + resolvedPath;
                  resolvedAbsolute = path.charAt(0) === "/";
                }
                resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
                  return !!p;
                }), !resolvedAbsolute).join("/");
                return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
              };
              exports2.normalize = function(path) {
                var isAbsolute = exports2.isAbsolute(path), trailingSlash = substr(path, -1) === "/";
                path = normalizeArray(filter(path.split("/"), function(p) {
                  return !!p;
                }), !isAbsolute).join("/");
                if (!path && !isAbsolute) {
                  path = ".";
                }
                if (path && trailingSlash) {
                  path += "/";
                }
                return (isAbsolute ? "/" : "") + path;
              };
              exports2.isAbsolute = function(path) {
                return path.charAt(0) === "/";
              };
              exports2.join = function() {
                var paths = Array.prototype.slice.call(arguments, 0);
                return exports2.normalize(filter(paths, function(p, index) {
                  if (typeof p !== "string") {
                    throw new TypeError("Arguments to path.join must be strings");
                  }
                  return p;
                }).join("/"));
              };
              exports2.relative = function(from, to) {
                from = exports2.resolve(from).substr(1);
                to = exports2.resolve(to).substr(1);
                function trim(arr) {
                  var start = 0;
                  for (; start < arr.length; start++) {
                    if (arr[start] !== "")
                      break;
                  }
                  var end = arr.length - 1;
                  for (; end >= 0; end--) {
                    if (arr[end] !== "")
                      break;
                  }
                  if (start > end)
                    return [];
                  return arr.slice(start, end - start + 1);
                }
                var fromParts = trim(from.split("/"));
                var toParts = trim(to.split("/"));
                var length = Math.min(fromParts.length, toParts.length);
                var samePartsLength = length;
                for (var i = 0; i < length; i++) {
                  if (fromParts[i] !== toParts[i]) {
                    samePartsLength = i;
                    break;
                  }
                }
                var outputParts = [];
                for (var i = samePartsLength; i < fromParts.length; i++) {
                  outputParts.push("..");
                }
                outputParts = outputParts.concat(toParts.slice(samePartsLength));
                return outputParts.join("/");
              };
              exports2.sep = "/";
              exports2.delimiter = ":";
              exports2.dirname = function(path) {
                var result = splitPath(path), root = result[0], dir = result[1];
                if (!root && !dir) {
                  return ".";
                }
                if (dir) {
                  dir = dir.substr(0, dir.length - 1);
                }
                return root + dir;
              };
              exports2.basename = function(path, ext) {
                var f = splitPath(path)[2];
                if (ext && f.substr(-1 * ext.length) === ext) {
                  f = f.substr(0, f.length - ext.length);
                }
                return f;
              };
              exports2.extname = function(path) {
                return splitPath(path)[3];
              };
              function filter(xs, f) {
                if (xs.filter)
                  return xs.filter(f);
                var res = [];
                for (var i = 0; i < xs.length; i++) {
                  if (f(xs[i], i, xs))
                    res.push(xs[i]);
                }
                return res;
              }
              var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
                return str.substr(start, len);
              } : function(str, start, len) {
                if (start < 0)
                  start = str.length + start;
                return str.substr(start, len);
              };
            }).call(exports2, __webpack_require__(7));
          },
          /* 38 */
          /***/
          function(module2, exports2, __webpack_require__) {
            (function(module3, global) {
              var __WEBPACK_AMD_DEFINE_RESULT__;
              ;
              (function(root) {
                var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
                var freeModule = typeof module3 == "object" && module3 && !module3.nodeType && module3;
                var freeGlobal = typeof global == "object" && global;
                if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                  root = freeGlobal;
                }
                var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                  "overflow": "Overflow: input needs wider integers to process",
                  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                  "invalid-input": "Invalid input"
                }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
                function error(type) {
                  throw new RangeError(errors[type]);
                }
                function map(array, fn) {
                  var length = array.length;
                  var result = [];
                  while (length--) {
                    result[length] = fn(array[length]);
                  }
                  return result;
                }
                function mapDomain(string, fn) {
                  var parts = string.split("@");
                  var result = "";
                  if (parts.length > 1) {
                    result = parts[0] + "@";
                    string = parts[1];
                  }
                  string = string.replace(regexSeparators, ".");
                  var labels = string.split(".");
                  var encoded = map(labels, fn).join(".");
                  return result + encoded;
                }
                function ucs2decode(string) {
                  var output = [], counter = 0, length = string.length, value, extra;
                  while (counter < length) {
                    value = string.charCodeAt(counter++);
                    if (value >= 55296 && value <= 56319 && counter < length) {
                      extra = string.charCodeAt(counter++);
                      if ((extra & 64512) == 56320) {
                        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                      } else {
                        output.push(value);
                        counter--;
                      }
                    } else {
                      output.push(value);
                    }
                  }
                  return output;
                }
                function ucs2encode(array) {
                  return map(array, function(value) {
                    var output = "";
                    if (value > 65535) {
                      value -= 65536;
                      output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                      value = 56320 | value & 1023;
                    }
                    output += stringFromCharCode(value);
                    return output;
                  }).join("");
                }
                function basicToDigit(codePoint) {
                  if (codePoint - 48 < 10) {
                    return codePoint - 22;
                  }
                  if (codePoint - 65 < 26) {
                    return codePoint - 65;
                  }
                  if (codePoint - 97 < 26) {
                    return codePoint - 97;
                  }
                  return base;
                }
                function digitToBasic(digit, flag) {
                  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                }
                function adapt(delta, numPoints, firstTime) {
                  var k = 0;
                  delta = firstTime ? floor(delta / damp) : delta >> 1;
                  delta += floor(delta / numPoints);
                  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                    delta = floor(delta / baseMinusTMin);
                  }
                  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                }
                function decode(input) {
                  var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
                  basic = input.lastIndexOf(delimiter);
                  if (basic < 0) {
                    basic = 0;
                  }
                  for (j = 0; j < basic; ++j) {
                    if (input.charCodeAt(j) >= 128) {
                      error("not-basic");
                    }
                    output.push(input.charCodeAt(j));
                  }
                  for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                    for (oldi = i, w = 1, k = base; ; k += base) {
                      if (index >= inputLength) {
                        error("invalid-input");
                      }
                      digit = basicToDigit(input.charCodeAt(index++));
                      if (digit >= base || digit > floor((maxInt - i) / w)) {
                        error("overflow");
                      }
                      i += digit * w;
                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                      if (digit < t) {
                        break;
                      }
                      baseMinusT = base - t;
                      if (w > floor(maxInt / baseMinusT)) {
                        error("overflow");
                      }
                      w *= baseMinusT;
                    }
                    out = output.length + 1;
                    bias = adapt(i - oldi, out, oldi == 0);
                    if (floor(i / out) > maxInt - n) {
                      error("overflow");
                    }
                    n += floor(i / out);
                    i %= out;
                    output.splice(i++, 0, n);
                  }
                  return ucs2encode(output);
                }
                function encode(input) {
                  var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                  input = ucs2decode(input);
                  inputLength = input.length;
                  n = initialN;
                  delta = 0;
                  bias = initialBias;
                  for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue < 128) {
                      output.push(stringFromCharCode(currentValue));
                    }
                  }
                  handledCPCount = basicLength = output.length;
                  if (basicLength) {
                    output.push(delimiter);
                  }
                  while (handledCPCount < inputLength) {
                    for (m = maxInt, j = 0; j < inputLength; ++j) {
                      currentValue = input[j];
                      if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                      }
                    }
                    handledCPCountPlusOne = handledCPCount + 1;
                    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                      error("overflow");
                    }
                    delta += (m - n) * handledCPCountPlusOne;
                    n = m;
                    for (j = 0; j < inputLength; ++j) {
                      currentValue = input[j];
                      if (currentValue < n && ++delta > maxInt) {
                        error("overflow");
                      }
                      if (currentValue == n) {
                        for (q = delta, k = base; ; k += base) {
                          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                          if (q < t) {
                            break;
                          }
                          qMinusT = q - t;
                          baseMinusT = base - t;
                          output.push(
                            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                          );
                          q = floor(qMinusT / baseMinusT);
                        }
                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                      }
                    }
                    ++delta;
                    ++n;
                  }
                  return output.join("");
                }
                function toUnicode(input) {
                  return mapDomain(input, function(string) {
                    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                  });
                }
                function toASCII(input) {
                  return mapDomain(input, function(string) {
                    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                  });
                }
                punycode = {
                  /**
                   * A string representing the current Punycode.js version number.
                   * @memberOf punycode
                   * @type String
                   */
                  "version": "1.4.1",
                  /**
                   * An object of methods to convert from JavaScript's internal character
                   * representation (UCS-2) to Unicode code points, and back.
                   * @see <https://mathiasbynens.be/notes/javascript-encoding>
                   * @memberOf punycode
                   * @type Object
                   */
                  "ucs2": {
                    "decode": ucs2decode,
                    "encode": ucs2encode
                  },
                  "decode": decode,
                  "encode": encode,
                  "toASCII": toASCII,
                  "toUnicode": toUnicode
                };
                if (true) {
                  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                    return punycode;
                  }).call(exports2, __webpack_require__, exports2, module3), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module3.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                } else if (freeExports && freeModule) {
                  if (module3.exports == freeExports) {
                    freeModule.exports = punycode;
                  } else {
                    for (key in punycode) {
                      punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                    }
                  }
                } else {
                  root.punycode = punycode;
                }
              })(this);
            }).call(exports2, __webpack_require__(41)(module2), __webpack_require__(5));
          },
          /* 39 */
          /***/
          function(module2, exports2) {
            if (typeof Object.create === "function") {
              module2.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                  constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
              };
            } else {
              module2.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {
                };
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
              };
            }
          },
          /* 40 */
          /***/
          function(module2, exports2) {
            module2.exports = function isBuffer(arg) {
              return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
            };
          },
          /* 41 */
          /***/
          function(module2, exports2) {
            module2.exports = function(module3) {
              if (!module3.webpackPolyfill) {
                module3.deprecate = function() {
                };
                module3.paths = [];
                if (!module3.children)
                  module3.children = [];
                Object.defineProperty(module3, "loaded", {
                  enumerable: true,
                  get: function() {
                    return module3.l;
                  }
                });
                Object.defineProperty(module3, "id", {
                  enumerable: true,
                  get: function() {
                    return module3.i;
                  }
                });
                module3.webpackPolyfill = 1;
              }
              return module3;
            };
          }
          /******/
        ])
      );
    });
  }
});
export default require_joi_browser();
/*! Bundled license information:

joi-browser/dist/joi-browser.js:
  (*!
  * The buffer module from node.js, for the browser.
  *
  * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
  * @license  MIT
  *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
  (*! https://mths.be/punycode v1.4.1 by @mathias *)
*/
//# sourceMappingURL=joi-browser.js.map
